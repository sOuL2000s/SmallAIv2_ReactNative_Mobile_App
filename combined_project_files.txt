CONTEXT 1 : 

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small AI v2</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Favicon -->
    <link rel="icon" href="logo.png" type="image/x-icon">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for modern typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Marked.js CDN for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Lucide Icons for a modern, futuristic feel -->
    <script src="https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /*
         * --- Custom Styles for AI Chat Assistant (Enhanced) ---
         * This section enhances the Tailwind CSS with a modern, futuristic theme,
         * including a vibrant color palette, subtle animations, and improved
         * responsiveness and UI elements, specifically for a chat-only interface.
         */
        
        /* Base font and transition settings for the whole page */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll if content overflows, let individual sections scroll */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.6s ease, color 0.6s ease;
            display: flex; /* Main flex container for sidebar and chat window */
            color: var(--text-primary); /* Use theme variables */
        }

        /* --- Theme Definitions --- */
        /*
         * Each theme has a dark and light variant defined by `body[data-theme="theme-name-mode"]`.
         * This allows for unique color palettes and background designs for each theme and its mode.
         */

        /* Default Theme: Light Mode */
        body[data-theme="default-light"] {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-color: #e5e7eb;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --header-bg: #f9fafb;
            --accent-primary: #6366f1;
            --accent-primary-hover: #4f46e5;
            --accent-secondary: #22d3ee;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #e0f2fe;
            --user-bubble-text: #1e40af;
            --ai-bubble-bg: #f3f4f6;
            --ai-bubble-text: #374151;
            --sidebar-bg: #ffffff;
            --sidebar-border: #e5e7eb;
            --sidebar-item-hover: #f3f4f6;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8); /* Slightly transparent */
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #1f2937;
            --conversation-indicator: #6366f1;


            background-image: radial-gradient(at 0% 0%, hsl(210, 30%, 95%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 20%, 90%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Default Theme: Dark Mode */
        body[data-theme="default-dark"] {
            --bg-primary: #0a0a0f;
            --bg-secondary: #13131a;
            --text-primary: #e5e7eb;
            --text-secondary: #a1a1aa;
            --border-color: #2d3748;
            --card-bg: #13131a;
            --card-border: #2d3748;
            --header-bg: #1f2937;
            --accent-primary: #818cf8;
            --accent-primary-hover: #6366f1;
            --accent-secondary: #67e8f9;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #1a237e;
            --user-bubble-text: #e0e7ff;
            --ai-bubble-bg: #2d3748;
            --ai-bubble-text: #f9fafb;
            --sidebar-bg: #13131a;
            --sidebar-border: #2d3748;
            --sidebar-item-hover: #1f2937;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(19, 19, 26, 0.9); /* Slightly transparent */
            --conversation-bg: rgba(19, 19, 26, 0.95);
            --conversation-text: #e5e7eb;
            --conversation-indicator: #818cf8;

            background-image: radial-gradient(at 0% 0%, hsl(240, 60%, 8%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(260, 50%, 8%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Celestial Horizon Theme: Dark Mode */
        body[data-theme="celestial-horizon-dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --text-primary: #C9D1D9;
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #1F2633;
            --card-border: #30363D;
            --header-bg: #161B22;
            --accent-primary: #58A6FF;
            --accent-primary-hover: #388BF2;
            --accent-secondary: #B1B8C1;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #253B64;
            --user-bubble-text: #E0F2FE;
            --ai-bubble-bg: #1F2633;
            --ai-bubble-text: #C9D1D9;
            --sidebar-bg: #161B22;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #1F2633;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 27, 34, 0.9);
            --conversation-bg: rgba(22, 27, 34, 0.95);
            --conversation-text: #C9D1D9;
            --conversation-indicator: #58A6FF;

            background-image: radial-gradient(at 0% 0%, hsl(220, 40%, 10%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(260, 40%, 10%) 0%, transparent 50%),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><filter id="f1" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur in="SourceGraphic" stdDeviation="0.3" /></filter></defs><rect width="100" height="100" fill="%230D1117" /><g filter="url(%23f1)" opacity="0.6"><circle cx="10" cy="15" r="0.2" fill="%23c9d1d9" /><circle cx="30" cy="5" r="0.3" fill="%2358A6FF" /><circle cx="50" cy="20" r="0.25" fill="%23c9d1d9" /><circle cx="70" cy="10" r="0.35" fill="%2358A6FF" /><circle cx="90" cy="25" r="0.3" fill="%23c9d1d9" /><circle cx="20" cy="40" r="0.3" fill="%2358A6FF" /><circle cx="45" cy="35" r="0.2" fill="%23c9d1d9" /><circle cx="65" cy="50" r="0.35" fill="%2358A6FF" /><circle cx="85" cy="40" r="0.25" fill="%23c9d1d9" /><circle cx="5" cy="60" r="0.35" fill="%2358A6FF" /><circle cx="25" cy="70" r="0.25" fill="%23c9d1d9" /><circle cx="40" cy="85" r="0.3" fill="%2358A6FF" /><circle cx="60" cy="75" r="0.2" fill="%23c9d1d9" /><circle cx="80" cy="90" r="0.35" fill="%2358A6FF" /><circle cx="95" cy="65" r="0.3" fill="%23c9d1d9" /></g></svg>');
            background-size: cover, cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Celestial Horizon Theme: Light Mode */
        body[data-theme="celestial-horizon-light"] {
            --bg-primary: #F0F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #2D3748;
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EDF2F7;
            --accent-primary: #3B82F6;
            --accent-primary-hover: #2563EB;
            --accent-secondary: #60A5FA;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBEAFE;
            --user-bubble-text: #1E40AF;
            --ai-bubble-bg: #EBF4FF;
            --ai-bubble-text: #2D3748;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #F0F4F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2D3748;
            --conversation-indicator: #3B82F6;

            background-image: radial-gradient(at 0% 0%, hsl(200, 50%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(240, 50%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Verdant Calm Theme: Dark Mode (Renamed from Forest Whisper) */
        body[data-theme="verdant-calm-dark"] {
            --bg-primary: #1a2a22;
            --bg-secondary: #21362d;
            --text-primary: #e0f2e8;
            --text-secondary: #99bbaa;
            --border-color: #3f544c;
            --card-bg: #294237;
            --card-border: #4a6356;
            --header-bg: #2c493c;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #1e8449;
            --user-bubble-text: #e0f2e8;
            --ai-bubble-bg: #34495e;
            --ai-bubble-text: #e0f2e8;
            --sidebar-bg: #21362d;
            --sidebar-border: #3f544c;
            --sidebar-item-hover: #2c493c;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(33, 54, 45, 0.9);
            --conversation-bg: rgba(33, 54, 45, 0.95);
            --conversation-text: #e0f2e8;
            --conversation-indicator: #3cb878;

            background-image: radial-gradient(at 0% 0%, hsl(150, 20%, 15%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(120, 20%, 12%) 0%, transparent 50%),
                              linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><filter id="f2" x="-50%" y="-50%" width="200%" height="200%"><feTurbulence type="fractalNoise" baseFrequency="0.6" numOctaves="3" result="noise" /><feDiffuseLighting in="noise" lightingColor="%234A6356" surfaceScale="5" result="light"><feDistantLight azimuth="235" elevation="60" /></feDiffuseLighting><feComposite in="SourceGraphic" in2="light" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" /></filter></defs><rect width="100" height="100" fill="%231a2a22" filter="url(%23f2)" /></svg>');
            background-size: cover, cover, cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Verdant Calm Theme: Light Mode */
        body[data-theme="verdant-calm-light"] {
            --bg-primary: #edf9f5;
            --bg-secondary: #ffffff;
            --text-primary: #2d3f35;
            --text-secondary: #5e7d6b;
            --border-color: #dbeae5;
            --card-bg: #ffffff;
            --card-border: #dbeae5;
            --header-bg: #f5fcf9;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #c8e6c9;
            --user-bubble-text: #1b5e20;
            --ai-bubble-bg: #e8f5e9;
            --ai-bubble-text: #388e3c;
            --sidebar-bg: #ffffff;
            --sidebar-border: #dbeae5;
            --sidebar-item-hover: #edf9f5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2d3f35;
            --conversation-indicator: #3cb878;

            background-image: radial-gradient(at 0% 0%, hsl(140, 20%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(100, 15%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Cybernetic Pulse Theme: Dark Mode */
        body[data-theme="cybernetic-pulse-dark"] {
            --bg-primary: #0a0e1a;
            --bg-secondary: #161c28;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2f3e52;
            --card-bg: #1f2a3a;
            --card-border: #3a4b5e;
            --header-bg: #1f2a3a;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #0c4a6e;
            --user-bubble-text: #e0f2fe;
            --ai-bubble-bg: #2d3748;
            --ai-bubble-text: #f0f8ff;
            --sidebar-bg: #161c28;
            --sidebar-border: #2f3e52;
            --sidebar-item-hover: #1f2a3a;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 28, 40, 0.9);
            --conversation-bg: rgba(22, 28, 40, 0.95);
            --conversation-text: #e2e8f0;
            --conversation-indicator: #0ea5e9;

            background-image: radial-gradient(at 0% 0%, hsl(210, 50%, 8%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(230, 40%, 8%) 0%, transparent 50%),
                              linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="circuit" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 L 0 10" fill="none" stroke="%232f3e52" stroke-width="0.3" /></pattern></defs><rect width="100" height="100" fill="url(%23circuit)" /></svg>');
            background-size: cover, cover, cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Cybernetic Pulse Theme: Light Mode */
        body[data-theme="cybernetic-pulse-light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --border-color: #e0e7f2;
            --card-bg: #ffffff;
            --card-border: #e0e7f2;
            --header-bg: #f1f5f9;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #bfdbfe;
            --user-bubble-text: #1e3a8a;
            --ai-bubble-bg: #e0f2fe;
            --ai-bubble-text: #0284c7;
            --sidebar-bg: #ffffff;
            --sidebar-border: #e0e7f2;
            --sidebar-item-hover: #f1f5f9;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #1e293b;
            --conversation-indicator: #0ea5e9;

            background-image: radial-gradient(at 0% 0%, hsl(200, 30%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(220, 20%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Urban Pulse Theme: Dark Mode */
        body[data-theme="urban-pulse-dark"] {
            --bg-primary: #1A1A1D;
            --bg-secondary: #242426;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0A0;
            --border-color: #38383B;
            --card-bg: #242426;
            --card-border: #38383B;
            --header-bg: #1A1A1D;
            --accent-primary: #00BFFF; /* Deep Sky Blue */
            --accent-primary-hover: #009ACD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #0F4C81;
            --user-bubble-text: #E0FFFF;
            --ai-bubble-bg: #36454F;
            --ai-bubble-text: #F0F0F0;
            --sidebar-bg: #1A1A1D;
            --sidebar-border: #38383B;
            --sidebar-item-hover: #242426;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(36, 36, 38, 0.9);
            --conversation-bg: rgba(36, 36, 38, 0.95);
            --conversation-text: #F0F0F0;
            --conversation-indicator: #00BFFF;

            background-image: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 L 0 10" fill="none" stroke="%23303030" stroke-width="0.3" /></pattern></defs><rect width="100" height="100" fill="url(%23grid)" /></svg>');
            background-size: cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Urban Pulse Theme: Light Mode */
        body[data-theme="urban-pulse-light"] {
            --bg-primary: #F2F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #333333;
            --text-secondary: #777777;
            --border-color: #DDE2E8;
            --card-bg: #FFFFFF;
            --card-border: #DDE2E8;
            --header-bg: #E8ECF2;
            --accent-primary: #1E90FF; /* Dodger Blue */
            --accent-primary-hover: #107EEB;
            --accent-secondary: #63B2FF;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #CCE5FF;
            --user-bubble-text: #003F8C;
            --ai-bubble-bg: #E8F0F5;
            --ai-bubble-text: #333333;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDE2E8;
            --sidebar-item-hover: #E8F0F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #333333;
            --conversation-indicator: #1E90FF;

            background-image: radial-gradient(at 0% 0%, hsl(210, 30%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 20%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Rustic Ember Theme: Dark Mode */
        body[data-theme="rustic-ember-dark"] {
            --bg-primary: #3E2723;
            --bg-secondary: #4E342E;
            --text-primary: #FBE9E7;
            --text-secondary: #BCAAA4;
            --border-color: #5D4037;
            --card-bg: #4E342E;
            --card-border: #5D4037;
            --header-bg: #3E2723;
            --accent-primary: #D84315;
            --accent-primary-hover: #BF360C;
            --accent-secondary: #FF8A65;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #8D6E63;
            --user-bubble-text: #FBE9E7;
            --ai-bubble-bg: #5D4037;
            --ai-bubble-text: #FBE9E7;
            --sidebar-bg: #3E2723;
            --sidebar-border: #5D4037;
            --sidebar-item-hover: #4E342E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(78, 52, 46, 0.9);
            --conversation-bg: rgba(78, 52, 46, 0.95);
            --conversation-text: #FBE9E7;
            --conversation-indicator: #D84315;

            background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.6)), url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><filter id="woodgrain" x="-50%" y="-50%" width="200%" height="200%"><feTurbulence type="fractalNoise" baseFrequency="0.05" numOctaves="4" stitchTiles="stitch" result="texture"/><feColorMatrix type="saturate" values="0.2"/><feComponentTransfer><feFuncR type="linear" slope="0.5" intercept="0.2"/><feFuncG type="linear" slope="0.5" intercept="0.1"/><feFuncB type="linear" slope="0.5" intercept="0"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="%233E2723" filter="url(%23woodgrain)"/></svg>');
            background-size: cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Rustic Ember Theme: Light Mode */
        body[data-theme="rustic-ember-light"] {
            --bg-primary: #F5E8DC;
            --bg-secondary: #FFFFFF;
            --text-primary: #4E342E;
            --text-secondary: #8D6E63;
            --border-color: #E6DCCD;
            --card-bg: #FFFFFF;
            --card-border: #E6DCCD;
            --header-bg: #F8EFE5;
            --accent-primary: #E65100;
            --accent-primary-hover: #D84315;
            --accent-secondary: #FFB74D;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FFCCBC;
            --user-bubble-text: #BF360C;
            --ai-bubble-bg: #FBE9E7;
            --ai-bubble-text: #4E342E;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6DCCD;
            --sidebar-item-hover: #F8EFE5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #4E342E;
            --conversation-indicator: #E65100;

            background-image: radial-gradient(at 0% 0%, hsl(30, 40%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(15, 30%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Neon Mirage Theme: Dark Mode */
        body[data-theme="neon-mirage-dark"] {
            --bg-primary: #05001C;
            --bg-secondary: #120033;
            --text-primary: #E0FFFF;
            --text-secondary: #8A2BE2;
            --border-color: #2F004F;
            --card-bg: #1A0040;
            --card-border: #2F004F;
            --header-bg: #120033;
            --accent-primary: #FF1493;
            --accent-primary-hover: #C7007C;
            --accent-secondary: #00BFFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #4B0082;
            --user-bubble-text: #E0FFFF;
            --ai-bubble-bg: #2E0854;
            --ai-bubble-text: #E0FFFF;
            --sidebar-bg: #120033;
            --sidebar-border: #2F004F;
            --sidebar-item-hover: #1A0040;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(26, 0, 64, 0.9);
            --conversation-bg: rgba(26, 0, 64, 0.95);
            --conversation-text: #E0FFFF;
            --conversation-indicator: #FF1493;

            background-image: radial-gradient(at 0% 0%, hsl(300, 80%, 15%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(240, 80%, 15%) 0%, transparent 50%),
                              linear-gradient(to top right, rgba(255, 20, 147, 0.1), transparent),
                              linear-gradient(to bottom left, rgba(0, 191, 255, 0.1), transparent);
            background-size: cover, cover, cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Neon Mirage Theme: Light Mode */
        body[data-theme="neon-mirage-light"] {
            --bg-primary: #F8F0FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #330066;
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #FF69B4;
            --accent-primary-hover: #E0509B;
            --accent-secondary: #87CEEB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FCE4EC;
            --user-bubble-text: #C2185B;
            --ai-bubble-bg: #F3E5F5;
            --ai-bubble-text: #330066;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #330066;
            --conversation-indicator: #FF69B4;

            background-image: radial-gradient(at 0% 0%, hsl(330, 80%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(270, 80%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Ivory Bloom Theme: Dark Mode */
        body[data-theme="ivory-bloom-dark"] {
            --bg-primary: #2B2D42;
            --bg-secondary: #4A4E69;
            --text-primary: #DCDCDC;
            --text-secondary: #A0A4B8;
            --border-color: #5D607E;
            --card-bg: #4A4E69;
            --card-border: #5D607E;
            --header-bg: #373A50;
            --accent-primary: #9B59B6;
            --accent-primary-hover: #8E44AD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #FFFFFF;
            --ai-bubble-bg: #5D607E;
            --ai-bubble-text: #DCDCDC;
            --sidebar-bg: #2B2D42;
            --sidebar-border: #5D607E;
            --sidebar-item-hover: #373A50;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(74, 78, 105, 0.9);
            --conversation-bg: rgba(74, 78, 105, 0.95);
            --conversation-text: #DCDCDC;
            --conversation-indicator: #9B59B6;

            background-image: radial-gradient(at 0% 0%, hsl(240, 20%, 20%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 20%, 18%) 0%, transparent 50%),
                              linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="petal" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M5 0 L6 4 L10 5 L6 6 L5 10 L4 6 L0 5 L4 4 Z" fill="%234A4E69" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23petal)"/></svg>');
            background-size: cover, cover, cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Ivory Bloom Theme: Light Mode */
        body[data-theme="ivory-bloom-light"] {
            --bg-primary: #FDFDFD;
            --bg-secondary: #FFFFFF;
            --text-primary: #333333;
            --text-secondary: #777777;
            --border-color: #EAEAEA;
            --card-bg: #FFFFFF;
            --card-border: #EAEAEA;
            --header-bg: #F5F5F5;
            --accent-primary: #8E44AD;
            --accent-primary-hover: #7F3C9E;
            --accent-secondary: #BA68C8;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #F2E6F7;
            --user-bubble-text: #5D2C7B;
            --ai-bubble-bg: #EAE0F0;
            --ai-bubble-text: #333333;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EAEAEA;
            --sidebar-item-hover: #F5F5F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #333333;
            --conversation-indicator: #8E44AD;

            background-image: radial-gradient(at 0% 0%, hsl(300, 10%, 99%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(280, 15%, 97%) 0%, transparent 50%),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="flower" width="15" height="15" patternUnits="userSpaceOnUse"><path d="M7.5 0 L9 4 L13 6 L9 8 L7.5 12 L6 8 L2 6 L6 4 Z" fill="%23EAEAEA" opacity="0.3"/></pattern></defs><rect width="100" height="100" fill="url(%23flower)"/></svg>');
            background-size: cover, cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Obsidian Night Theme: Dark Mode */
        body[data-theme="obsidian-night-dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1E1E1E;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0A0;
            --border-color: #333333;
            --card-bg: #1E1E1E;
            --card-border: #333333;
            --header-bg: #121212;
            --accent-primary: #BB86FC;
            --accent-primary-hover: #9E65E2;
            --accent-secondary: #03DAC6;
            --accent-error: #CF6679;
            --accent-success: #03DAC6;
            --user-bubble-bg: #3700B3;
            --user-bubble-text: #FFFFFF;
            --ai-bubble-bg: #2C2C2C;
            --ai-bubble-text: #F0F0F0;
            --sidebar-bg: #121212;
            --sidebar-border: #333333;
            --sidebar-item-hover: #1E1E1E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(30, 30, 30, 0.9);
            --conversation-bg: rgba(30, 30, 30, 0.95);
            --conversation-text: #F0F0F0;
            --conversation-indicator: #BB86FC;

            background-image: radial-gradient(at 0% 0%, hsl(250, 10%, 10%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 10%, 10%) 0%, transparent 50%),
                              linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.8)),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="dark-hex" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M0 5 L5 0 L10 5 L5 10 Z" fill="none" stroke="%23333333" stroke-width="0.2"/></pattern></defs><rect width="100" height="100" fill="url(%23dark-hex)"/></svg>');
            background-size: cover, cover, cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Obsidian Night Theme: Light Mode */
        body[data-theme="obsidian-night-light"] {
            --bg-primary: #E0E0E0;
            --bg-secondary: #FFFFFF;
            --text-primary: #2C2C2C;
            --text-secondary: #6B6B6B;
            --border-color: #C0C0C0;
            --card-bg: #FFFFFF;
            --card-border: #C0C0C0;
            --header-bg: #D0D0D0;
            --accent-primary: #6200EE;
            --accent-primary-hover: #5B00D9;
            --accent-secondary: #018786;
            --accent-error: #B00020;
            --accent-success: #018786;
            --user-bubble-bg: #BBDEFB;
            --user-bubble-text: #1A237E;
            --ai-bubble-bg: #E0E0E0;
            --ai-bubble-text: #2C2C2C;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #C0C0C0;
            --sidebar-item-hover: #D0D0D0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2C2C2C;
            --conversation-indicator: #6200EE;

            background-image: radial-gradient(at 0% 0%, hsl(240, 10%, 95%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 10%, 92%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Solar Dawn Theme: Dark Mode */
        body[data-theme="solar-dawn-dark"] {
            --bg-primary: #1A0E2A;
            --bg-secondary: #2C1840;
            --text-primary: #FCE8D8;
            --text-secondary: #D8BFD8;
            --border-color: #40265B;
            --card-bg: #2C1840;
            --card-border: #40265B;
            --header-bg: #1A0E2A;
            --accent-primary: #FF5722;
            --accent-primary-hover: #E64A19;
            --accent-secondary: #FFCC80;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #FCE8D8;
            --ai-bubble-bg: #40265B;
            --ai-bubble-text: #FCE8D8;
            --sidebar-bg: #1A0E2A;
            --sidebar-border: #40265B;
            --sidebar-item-hover: #2C1840;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(44, 24, 64, 0.9);
            --conversation-bg: rgba(44, 24, 64, 0.95);
            --conversation-text: #FCE8D8;
            --conversation-indicator: #FF5722;

            background-image: linear-gradient(to top right, #3C096C, #6D2B7E, #FF5722);
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Solar Dawn Theme: Light Mode */
        body[data-theme="solar-dawn-light"] {
            --bg-primary: #FFFBEA;
            --bg-secondary: #FFFFFF;
            --text-primary: #3E2723;
            --text-secondary: #8D6E63;
            --border-color: #FFE0B2;
            --card-bg: #FFFFFF;
            --card-border: #FFE0B2;
            --header-bg: #FFF3E0;
            --accent-primary: #FF8F00;
            --accent-primary-hover: #FF6F00;
            --accent-secondary: #FFD54F;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #FFE0B2;
            --user-bubble-text: #E65100;
            --ai-bubble-bg: #FFF3E0;
            --ai-bubble-text: #3E2723;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #FFE0B2;
            --sidebar-item-hover: #FFF3E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #3E2723;
            --conversation-indicator: #FF8F00;

            background-image: linear-gradient(to top left, #FFD54F, #FFECB3, #FFFDE7);
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Aurora Drift Theme: Dark Mode */
        body[data-theme="aurora-drift-dark"] {
            --bg-primary: #0A192F;
            --bg-secondary: #172A45;
            --text-primary: #E6F0FF;
            --text-secondary: #A0B3D6;
            --border-color: #2F476D;
            --card-bg: #172A45;
            --card-border: #2F476D;
            --header-bg: #0A192F;
            --accent-primary: #66CCCC;
            --accent-primary-hover: #55B3B3;
            --accent-secondary: #99CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #336699;
            --user-bubble-text: #E6F0FF;
            --ai-bubble-bg: #2F476D;
            --ai-bubble-text: #E6F0FF;
            --sidebar-bg: #0A192F;
            --sidebar-border: #2F476D;
            --sidebar-item-hover: #172A45;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(23, 42, 69, 0.9);
            --conversation-bg: rgba(23, 42, 69, 0.95);
            --conversation-text: #E6F0FF;
            --conversation-indicator: #66CCCC;

            background-image: linear-gradient(to top right, #0A192F, #172A45, #2F476D, #336699);
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
            animation: aurora-move 60s infinite alternate;
        }

        /* Aurora Drift Theme: Light Mode */
        body[data-theme="aurora-drift-light"] {
            --bg-primary: #E0F2F7;
            --bg-secondary: #FFFFFF;
            --text-primary: #2B4550;
            --text-secondary: #5E7A8A;
            --border-color: #B2EBF2;
            --card-bg: #FFFFFF;
            --card-border: #B2EBF2;
            --header-bg: #CCEEF0;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #00ACC1;
            --accent-secondary: #4DD0E1;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #B2EBF2;
            --user-bubble-text: #006064;
            --ai-bubble-bg: #CCEEF0;
            --ai-bubble-text: #2B4550;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #B2EBF2;
            --sidebar-item-hover: #CCEEF0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2B4550;
            --conversation-indicator: #00BCD4;

            background-image: linear-gradient(to bottom left, #E0F7FA, #B2EBF2, #80DEEA);
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
        }
        @keyframes aurora-move {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Timeless Echo Theme: Dark Mode */
        body[data-theme="timeless-echo-dark"] {
            --bg-primary: #2C2C2C;
            --bg-secondary: #3D3D3D;
            --text-primary: #E0E0E0;
            --text-secondary: #B0B0B0;
            --border-color: #555555;
            --card-bg: #3D3D3D;
            --card-border: #555555;
            --header-bg: #2C2C2C;
            --accent-primary: #A57C52;
            --accent-primary-hover: #8B653D;
            --accent-secondary: #C8A87C;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #785A3D;
            --user-bubble-text: #E0E0E0;
            --ai-bubble-bg: #555555;
            --ai-bubble-text: #E0E0E0;
            --sidebar-bg: #2C2C2C;
            --sidebar-border: #555555;
            --sidebar-item-hover: #3D3D3D;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(61, 61, 61, 0.9);
            --conversation-bg: rgba(61, 61, 61, 0.95);
            --conversation-text: #E0E0E0;
            --conversation-indicator: #A57C52;

            background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.6)), url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><filter id="f3" x="-50%" y="-50%" width="200%" height="200%"><feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="3" result="noise" /><feColorMatrix type="saturate" values="0.3"/><feComponentTransfer><feFuncR type="linear" slope="0.8" intercept="0.1"/><feFuncG type="linear" slope="0.7" intercept="0.1"/><feFuncB type="linear" slope="0.6" intercept="0.1"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="%232C2C2C" filter="url(%23f3)" /></svg>');
            background-size: cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Timeless Echo Theme: Light Mode */
        body[data-theme="timeless-echo-light"] {
            --bg-primary: #FDF7E5;
            --bg-secondary: #FFFFFF;
            --text-primary: #4A4A4A;
            --text-secondary: #808080;
            --border-color: #E6E0D3;
            --card-bg: #FFFFFF;
            --card-border: #E6E0D3;
            --header-bg: #F5EFEB;
            --accent-primary: #8D6E63;
            --accent-primary-hover: #795548;
            --accent-secondary: #BCAAA4;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #D7CCC8;
            --user-bubble-text: #5D4037;
            --ai-bubble-bg: #EFEBE9;
            --ai-bubble-text: #4A4A4A;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6E0D3;
            --sidebar-item-hover: #F5EFEB;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #4A4A4A;
            --conversation-indicator: #8D6E63;

            background-image: radial-gradient(at 0% 0%, hsl(40, 30%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 20%, 95%) 0%, transparent 50%),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="vintage-pattern" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 0 0 L 10 10 M 10 0 L 0 10" stroke="%23E6E0D3" stroke-width="0.5" opacity="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23vintage-pattern)"/></svg>');
            background-size: cover, cover, auto;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Mystic Void Theme: Dark Mode (Bonus Theme) */
        body[data-theme="mystic-void-dark"] {
            --bg-primary: #110B1D;
            --bg-secondary: #1F1731;
            --text-primary: #ECE4F7;
            --text-secondary: #B29BCE;
            --border-color: #372A4F;
            --card-bg: #1F1731;
            --card-border: #372A4F;
            --header-bg: #110B1D;
            --accent-primary: #9400D3;
            --accent-primary-hover: #7B00B0;
            --accent-secondary: #8A2BE2;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #5B2C7B;
            --user-bubble-text: #ECE4F7;
            --ai-bubble-bg: #372A4F;
            --ai-bubble-text: #ECE4F7;
            --sidebar-bg: #110B1D;
            --sidebar-border: #372A4F;
            --sidebar-item-hover: #1F1731;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(31, 23, 49, 0.9);
            --conversation-bg: rgba(31, 23, 49, 0.95);
            --conversation-text: #ECE4F7;
            --conversation-indicator: #9400D3;

            background-image: radial-gradient(at 0% 0%, hsl(270, 60%, 10%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(300, 50%, 10%) 0%, transparent 50%),
                              linear-gradient(to top right, rgba(138, 43, 226, 0.1), transparent),
                              linear-gradient(to bottom left, rgba(148, 0, 211, 0.1), transparent);
            background-size: cover, cover, cover, cover;
            background-position: center center;
            background-attachment: fixed;
        }

        /* Mystic Void Theme: Light Mode */
        body[data-theme="mystic-void-light"] {
            --bg-primary: #F7EDFF;
            --bg-secondary: #FFFFFF;
            --text-primary: #330066;
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #8A2BE2;
            --accent-primary-hover: #7B1FB2;
            --accent-secondary: #9370DB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #E6D2F2;
            --user-bubble-text: #4B0082;
            --ai-bubble-bg: #F0E6F8;
            --ai-bubble-text: #330066;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #330066;
            --conversation-indicator: #8A2BE2;

            background-image: radial-gradient(at 0% 0%, hsl(270, 30%, 98%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(300, 20%, 95%) 0%, transparent 50%);
            background-size: cover;
            background-attachment: fixed;
        }

        /* Darkest Black & White Theme: Dark Mode (Corrected Bubbles & Icons) */
        body[data-theme="darkest-bw-dark"] {
            --bg-primary: #000000; /* Pure black main body background */
            --bg-secondary: #111111; /* Slightly off-black for card/secondary elements */
            --text-primary: #FFFFFF; /* Pure white main text */
            --text-secondary: #AAAAAA; /* Light gray for subtle text */
            --border-color: #333333; /* Dark gray borders */
            --card-bg: #111111;
            --card-border: #333333;
            --header-bg: #0A0A0A; /* Very dark gray for header */
            --accent-primary: #E0E0E0; /* Bright light gray for primary accents (buttons, active states) */
            --accent-primary-hover: #FFFFFF; /* Pure white for hover glow */
            --accent-secondary: #888888; /* Mid-gray for secondary accents */
            --accent-error: #F87171; /* Keep standard error color for usability */
            --accent-success: #4ADE80; /* Keep standard success color for usability */
            --user-bubble-bg: #222222; /* Dark gray for user chat bubbles */
            --user-bubble-text: #FFFFFF; /* White text for user chat bubbles */
            --ai-bubble-bg: #333333; /* Dark gray for AI chat bubbles */
            --ai-bubble-text: #FFFFFF; /* White text for AI chat bubbles */
            --sidebar-bg: #000000;
            --sidebar-border: #333333;
            --sidebar-item-hover: #111111;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #000000; /* Solid off-black for chat window */
            --conversation-bg: #000000; /* Solid pure black for conversation overlay */
            --conversation-text: #FFFFFF;
            --conversation-indicator: #FFFFFF;

            background-image: none;
            background-color: var(--bg-primary);
        }

        /* Darkest Black & White Theme: Light Mode (Revised) */
        body[data-theme="darkest-bw-light"] {
            --bg-primary: #FFFFFF; /* Pure white main body background */
            --bg-secondary: #F0F0F0; /* Slightly off-white for card/secondary elements */
            --text-primary: #000000; /* Pure black main text */
            --text-secondary: #555555; /* Dark gray for subtle text */
            --border-color: #DDDDDD; /* Light gray borders */
            --card-bg: #F0F0F0;
            --card-border: #DDDDDD;
            --header-bg: #F5F5F5; /* Very light gray for header */
            --accent-primary: #333333; /* Dark gray for primary accents (buttons, active states) */
            --accent-primary-hover: #000000; /* Pure black for hover */
            --accent-secondary: #777777; /* Mid-gray for secondary accents */
            --accent-error: #EF4444; /* Keep standard error color for usability */
            --accent-success: #22C55E; /* Keep standard success color for usability */
            --user-bubble-bg: #EEEEEE; /* Very light gray for user chat bubbles */
            --user-bubble-text: #000000;
            --ai-bubble-bg: #DDDDDD; /* Slightly darker light gray for AI chat bubbles */
            --ai-bubble-text: #000000;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDDDDD;
            --sidebar-item-hover: #F0F0F0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #F0F0F0; /* Solid off-white for chat window */
            --conversation-bg: #FFFFFF; /* Solid pure white for conversation overlay */
            --conversation-text: #000000;
            --conversation-indicator: #000000; /* Pure black indicator for conversation mode */

            /* Removed all background-image properties for a solid background */
            background-image: none;
            background-color: var(--bg-primary); /* Explicitly set body background to primary color */
        }

        /* --- Global Styles & Overrides --- */

        /* Apply theme colors */
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Specific Tailwind overrides for consistency with theme variables */
        .bg-white { background-color: var(--card-bg); }
        .bg-gray-50 { background-color: var(--header-bg); }
        .border-gray-100 { border-color: var(--card-border); }
        .border-gray-200 { border-color: var(--card-border); }
        .text-gray-800 { color: var(--text-primary); }
        .text-gray-900 { color: var(--text-primary); }
        .text-gray-600 { color: var(--text-secondary); }
        .text-gray-700 { color: var(--text-secondary); }
        .bg-gray-200 { background-color: var(--bg-primary); color: var(--text-primary); }
        .hover\:bg-gray-300:hover { background-color: var(--sidebar-item-hover); }
        .bg-gray-100 { background-color: var(--bg-primary); }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        body[data-theme$="-dark"] .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45); }
        #error-message { background-color: var(--accent-error); color: white; } /* Light red for error, always visible */
        body[data-theme$="-dark"] #error-message { background-color: var(--accent-error); color: white; }

        /* Custom styles for glowing effects on buttons */
        .glow-button {
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
            box-shadow: 0 0 10px var(--accent-primary);
            background-color: var(--accent-primary); /* Ensure button uses accent primary directly */
        }
        .glow-button:hover {
            box-shadow: 0 0 15px var(--accent-primary), 0 0 25px var(--accent-primary), 0 0 35px var(--accent-primary);
            transform: translateY(-2px) scale(1.02);
            background-image: linear-gradient(to right, var(--accent-primary), var(--accent-primary-hover));
        }
        
        /* Markdown content styling for better readability */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { font-weight: 800; margin-bottom: 0.75em; margin-top: 1.5em; line-height: 1.2; color: var(--accent-primary); }
        .markdown-content h1 { font-size: 2.25rem; }
        .markdown-content h2 { font-size: 1.875rem; }
        .markdown-content h3 { font-size: 1.5rem; }
        .markdown-content ul, .markdown-content ol { list-style-position: inside; margin-left: 1.5em; margin-bottom: 1em; }
        .markdown-content li { margin-bottom: 0.5em; }
        .markdown-content strong { color: var(--accent-secondary); font-weight: 700; }
        .markdown-content p { margin-bottom: 1em; }
        .markdown-content p:last-child { margin-bottom: 0; }

        /* Custom styles for dark mode toggle switch */
        .switch { margin-left: 0.5rem; }
        .slider { background-color: var(--text-secondary); transition: .4s; } /* Use theme secondary text for inactive */
        input:checked + .slider { background-color: var(--accent-primary); }
        input:checked + .slider:before { transform: translateX(24px); }
        .slider:before { background-color: var(--bg-secondary); transition: .4s; } /* Use a lighter background for the thumb */

        /* Custom scrollbar for a sleek look (hidden) */
        #sidebar-chat-list::-webkit-scrollbar,
        #chat-input::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
        }
        #sidebar-chat-list,
        #chat-input {
            -ms-overflow-style: none; /* Internet Explorer and Edge */
            scrollbar-width: none; /* Firefox */
        }

        /* Styles specifically for #chat-history scrollbar */
        #chat-history {
            overflow-y: auto; /* Ensure vertical scrolling is enabled */
            overflow-x: hidden; /* Keep hidden to prevent horizontal content overflow */

            /* Firefox scrollbar styles */
            scrollbar-width: thin; /* 'auto' or 'thin' */
            scrollbar-color: var(--accent-primary) var(--sidebar-item-hover); /* thumb color track color */
        }

        /* Webkit (Chrome, Safari, Edge) scrollbar styles for #chat-history */
        #chat-history::-webkit-scrollbar {
            width: 8px; /* Width of the vertical scrollbar */
        }

        #chat-history::-webkit-scrollbar-track {
            background: var(--sidebar-item-hover); /* Background of the scrollbar track */
            border-radius: 10px;
        }

        #chat-history::-webkit-scrollbar-thumb {
            background-color: var(--accent-primary); /* Color of the scrollbar thumb */
            border-radius: 10px; /* Rounded corners for the thumb */
            border: 2px solid var(--sidebar-item-hover); /* Creates a border effect and separates from track */
        }

        #chat-history::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary-hover); /* Darker thumb on hover */
        }
        
        /* Modern loading animation */
        .loader-container { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
        .loader-dot {
            width: 12px; height: 12px; margin: 0 4px;
            background-color: var(--loader-dot-color);
            border-radius: 50%; display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .loader-dot:nth-child(1) { animation-delay: -0.32s; }
        .loader-dot:nth-child(2) { animation-delay: -0.16s; }
        .loader-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
            40% { transform: scale(1.0); opacity: 1; }
        }

        /* Main Chat Window Styling */
        #main-chat-window {
            flex: 1;
            max-width: 100%;
            min-height: 100vh;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--main-chat-window-bg); /* Use theme variable for transparency */
            border-radius: 0;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border-left: 1px solid var(--border-color); /* Use theme border color */
            transition: all 0.3s ease-in-out;
            /* REMOVE THESE TWO LINES: */
            /* backdrop-filter: blur(8px); */
            /* -webkit-backdrop-filter: blur(8px); */
        }
        body[data-theme$="-dark"] #main-chat-window {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45);
        }

        /* Sidebar Styling */
        #sidebar {
            width: 280px;
            min-width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            padding: 1rem;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 30;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
        }
        #sidebar.hidden-mobile {
            transform: translateX(-100%);
            position: absolute;
            left: 0;
            box-shadow: none;
        }
        @media (min-width: 768px) { /* md breakpoint */
            body {
                justify-content: flex-start;
                align-items: stretch;
            }
            #sidebar {
                position: relative;
                transform: translateX(0%);
                border-radius: 0;
            }
            #sidebar.hidden-mobile {
                transform: translateX(0%);
                position: relative;
            }
            #main-chat-window {
                max-width: none;
                border-radius: 0;
            }
            #hamburger-menu-button { display: none !important; }
        }
        
        /* New chat message styles */
        .chat-message {
            margin-bottom: 0.75rem; padding: 1rem; border-radius: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            word-break: break-word; transition: all 0.3s ease; transform: scale(0.95);
            transform-origin: bottom; max-width: 85%; position: relative; padding-bottom: 2.5rem;
        }

        .chat-message.user {
            background-color: var(--user-bubble-bg); color: var(--user-bubble-text);
            margin-left: auto; border-bottom-right-radius: 0.5rem;
            background-image: linear-gradient(to bottom right, var(--user-bubble-bg), color-mix(in srgb, var(--user-bubble-bg) 80%, var(--accent-primary) 20%));
        }

        .chat-message.ai {
            background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text);
            margin-right: auto; border-bottom-left-radius: 0.5rem;
            background-image: linear-gradient(to bottom left, var(--ai-bubble-bg), color-mix(in srgb, var(--ai-bubble-bg) 80%, var(--border-color) 20%));
        }

        /* Styling for chat attachments */
        .chat-image { max-width: 100%; height: auto; border-radius: 0.75rem; margin-top: 0.5rem; display: block; }
        .chat-attachment-preview-item {
            display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem;
            border-radius: 1rem; background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary); font-size: 0.875rem; box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn {
            background: none; border: none; color: var(--accent-primary); cursor: pointer;
            padding: 0.1rem; border-radius: 50%; transition: background-color 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn:hover {
            background-color: color-mix(in srgb, var(--accent-primary) 20%, transparent);
        }

        /* Styling for the copy message */
        #copy-message {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);
            padding: 0.75rem 1.5rem; background-color: var(--accent-success); color: white;
            border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0; visibility: hidden; transition: all 0.5s ease-in-out; z-index: 100;
        }
        #copy-message.show { opacity: 1; visibility: visible; bottom: 4rem; }

        /* --- New/Enhanced Styles for Chat AI Responses & Code Blocks --- */
        
        .chat-message .message-content { padding: 0; margin: 0; }
        .chat-message.ai .message-content p, .chat-message.ai .message-content ul,
        .chat-message.ai .message-content ol, .chat-message.ai .message-content h1,
        .chat-message.ai .message-content h2, .chat-message.ai .message-content h3,
        .chat-message.ai .message-content blockquote { margin-bottom: 1em; }
        .chat-message.ai .message-content p:last-child, .chat-message.ai .message-content ul:last-child,
        .chat-message.ai .message-content ol:last-child, .chat-message.ai .message-content blockquote:last-child { margin-bottom: 0; }
        .chat-message.ai .message-content ul, .chat-message.ai .message-content ol { padding-left: 1.5em; }
        .chat-message.ai .message-content li { margin-bottom: 0.5em; }
        .chat-message.ai .message-content strong { font-weight: bold; color: var(--accent-primary); }
        .chat-message.ai .message-content em { font-style: italic; }
        .chat-message.ai .message-content blockquote {
            border-left: 4px solid var(--accent-secondary); padding-left: 1em;
            margin-left: 0; color: var(--text-secondary);
        }

        /* Code block specific styling */
        .code-block-container {
            position: relative; background-color: #27272a; color: #f8f8f2; /* Hardcoded for contrast on any theme, can be themed if desired */
            border-radius: 0.75rem; margin-top: 1rem; margin-bottom: 1rem;
            overflow: hidden; border: 1px solid #3f3f46; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .code-block-container pre {
            margin: 0; padding: 1rem; overflow-x: auto;
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em; line-height: 1.4;
        }
        .code-block-header {
            display: flex; justify-content: space-between; align-items: center;
            background-color: #374151; color: #d1d5db; padding: 0.5rem 1rem; /* Hardcoded */
            border-bottom: 1px solid #4b5563; font-size: 0.85em; /* Hardcoded */
            border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem;
        }
        .code-block-copy-button {
            background-color: transparent; border: none; color: #d1d5db; /* Hardcoded */
            cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; gap: 0.25rem; font-size: 0.85em;
        }
        .code-block-copy-button:hover { background-color: #4b5563; color: white; } /* Hardcoded */
        .code-block-copy-button:active { transform: scale(0.95); }

        /* Smallest font size for inline code blocks if any */
        .chat-message.ai .message-content code:not(pre > code) {
            background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent); /* Themed */
            border-radius: 0.25rem;
            padding: 0.2em 0.4em; font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em; color: var(--accent-primary); /* Themed */
        }

        /* Ensure links are distinguishable */
        .chat-message.ai .message-content a {
            color: var(--accent-primary); text-decoration: underline; transition: color 0.2s ease;
        }
        .chat-message.ai .message-content a:hover { color: var(--accent-primary-hover); }

        /* Styles for message action buttons (copy/dictate) */
        .message-actions {
            position: absolute; bottom: 0.5rem; right: 1rem; display: flex; gap: 0.5rem;
            padding: 0.25rem 0.5rem; background-color: var(--header-bg); /* Use a themed background for the actions panel */
            border-radius: 0.75rem; backdrop-filter: blur(5px); transition: opacity 0.3s ease;
            opacity: 0; z-index: 10;
            border: 1px solid var(--border-color);
        }
        .chat-message:hover .message-actions { opacity: 1; }
        .message-actions button {
            background: none; border: none; cursor: pointer; padding: 0.25rem;
            border-radius: 0.375rem; transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; justify-content: center;
        }
        .message-actions button .lucide { color: var(--text-secondary); width: 1rem; height: 1rem; }
        .message-actions button:hover .lucide { color: var(--text-primary); }
        .message-actions button:hover { background-color: var(--sidebar-item-hover); } /* Themed hover */
        .chat-message.user .message-actions { right: 1rem; left: auto; }
        .chat-message.ai .message-actions { left: 1rem; right: auto; }

        /* New style for speech recognition button when active */
        .voice-input-active {
            background-color: var(--accent-error) !important;
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 10px color-mix(in srgb, var(--accent-error) 0%, transparent); }
        }
        
        /* Drag and Drop visual feedback for chat input area */
        #chat-input-area-container.drag-over-active {
            border: 2px dashed var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-primary), 0 0 30px var(--accent-primary) inset;
        }
        
        /* Sidebar chat list item styling */
        .sidebar-chat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-align: left;
        }
        .sidebar-chat-item:hover {
            background-color: var(--sidebar-item-hover);
            color: var(--text-primary);
        }
        .sidebar-chat-item.active {
            background-color: var(--accent-primary);
            color: black; /* Changed to black */
            font-weight: 600;
        }
        .sidebar-chat-item.active .lucide {
            color: black; /* Changed to black */
        }
        .sidebar-chat-item.active:hover {
            background-color: var(--accent-primary-hover);
        }
        .sidebar-chat-item-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-grow: 1;
            min-width: 0;
        }
        .sidebar-chat-item-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .sidebar-chat-item-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .sidebar-chat-item:hover .sidebar-chat-item-actions {
            opacity: 1;
        }
        .sidebar-chat-item-actions button {
            background: none;
            border: none;
            padding: 0.25rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .sidebar-chat-item-actions button .lucide {
            width: 1rem;
            height: 1rem;
            color: var(--text-secondary);
        }
        .sidebar-chat-item-actions button:hover {
            background-color: var(--sidebar-item-hover);
        }
        .sidebar-chat-item.active .sidebar-chat-item-actions button .lucide {
            color: white;
        }

        /* Responsive menu button for sidebar */
        #hamburger-menu-button {
            display: flex;
            margin-right: 1rem;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.5rem;
            background-color: var(--header-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #hamburger-menu-button:hover {
            background-color: var(--sidebar-item-hover);
        }

        /* Overlay for mobile sidebar */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 29;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* --- Conversation Mode Overlay Styles --- */
        #conversation-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-bg); /* Themed background */
            color: var(--conversation-text); /* Themed text */
            z-index: 100; /* Ensure it's on top */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            visibility: hidden;
            backdrop-filter: blur(10px) brightness(0.8); /* Stronger blur, slightly darker */
            -webkit-backdrop-filter: blur(10px) brightness(0.8);
            padding: 1rem;
            overflow-y: auto; /* Allow scrolling if content overflows on small screens */

            /* Add a subtle animated background for depth */
            background-image: radial-gradient(circle at 15% 50%, color-mix(in srgb, var(--accent-primary) 20%, transparent), transparent 70%),
                              radial-gradient(circle at 85% 50%, color-mix(in srgb, var(--accent-secondary) 20%, transparent), transparent 70%),
                              linear-gradient(135deg, color-mix(in srgb, var(--conversation-bg) 90%, black 10%) 0%, transparent 50%);
            background-size: 200% 200%; /* Larger to allow animation */
            background-position: center center;
            animation: background-drift 30s infinite alternate ease-in-out;
        }

        #conversation-mode-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @keyframes background-drift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        #conversation-mode-close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            color: var(--text-secondary); /* Use a more subtle color */
            cursor: pointer;
            z-index: 110;
            padding: 0.5rem;
            border-radius: 50%;
            transition: color 0.3s ease, transform 0.2s ease;
        }
        #conversation-mode-close-btn:hover {
            color: var(--text-primary); /* Brighter on hover */
            transform: scale(1.1);
        }

        .conversation-controls {
            position: absolute; /* Position controls at the top */
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 105;
            flex-wrap: wrap;
            justify-content: center;
            background-color: color-mix(in srgb, var(--conversation-bg) 60%, transparent); /* Semi-transparent background */
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* Pill shape */
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 90%;
        }
        @media (max-width: 768px) {
            .conversation-controls {
                top: 0.5rem;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
                width: auto;
                border-radius: 0.75rem;
            }
        }


        .conversation-controls label { /* Added label for clarity, not strictly needed for current HTML */
            color: var(--text-secondary);
            font-size: 0.85rem;
            align-self: center; /* Align with dropdowns */
            margin-right: -0.5rem; /* bring closer to dropdown */
        }
        .conversation-controls select {
            background-color: var(--card-bg); /* Use card-bg for better contrast */
            border-color: var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        .conversation-controls select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }

        .sound-blob-wrapper { /* New wrapper for multiple blobs */
            position: relative;
            width: 300px; /* Larger base size */
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            perspective: 1000px; /* For potential 3D effects */
            margin-top: 8rem; /* Push down due to controls at top */
        }
        @media (max-width: 768px) {
            .sound-blob-wrapper {
                width: 200px;
                height: 200px;
                margin-top: 12rem; /* Even more for stacked controls */
            }
        }

        /* Base blob styles */
        .sound-blob {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-indicator);
            border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%; /* Organic, fluid shape */
            opacity: 0.7;
            filter: blur(8px) drop-shadow(0 0 25px var(--conversation-indicator)); /* Glowing effect */
            transition: all 0.5s ease;
            will-change: transform, opacity, background-color, filter;
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
        }

        /* Additional concentric blobs */
        .sound-blob::before,
        .sound-blob::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit; /* Inherit parent's organic shape */
            background-color: inherit;
            opacity: 0.5;
            filter: blur(15px);
            animation: idle-blob-morph 18s infinite alternate-reverse ease-in-out;
            transform: scale(1.05);
            z-index: -1; /* Behind the main blob */
        }

        .sound-blob::after {
            opacity: 0.3;
            filter: blur(20px);
            animation: idle-blob-morph 20s infinite alternate ease-in-out;
            transform: scale(1.1);
            animation-delay: 2s; /* Stagger animation */
        }

        @keyframes idle-blob-morph {
            0% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
            50% {
                border-radius: 30% 50% 40% 60% / 60% 40% 50% 30%;
                transform: scale(1.05) rotate(10deg);
                opacity: 0.8;
            }
            100% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
        }

        .sound-blob.listening-animation {
            animation: listen-pulse 1.2s infinite ease-out, listen-color-shift 3s infinite alternate;
            border-radius: 50%; /* More circular when active */
            filter: blur(5px) drop-shadow(0 0 30px var(--conversation-indicator));
            opacity: 0.9;
        }
        .sound-blob.listening-animation::before,
        .sound-blob.listening-animation::after {
            animation: listen-ring-pulse 1.5s infinite ease-out;
            border-radius: 50%;
        }

        @keyframes listen-pulse {
            0% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.05) rotate(5deg); opacity: 1; filter: blur(5px) drop-shadow(0 0 40px var(--conversation-indicator)); }
            100% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
        }
        @keyframes listen-ring-pulse {
            0% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
            50% { transform: scale(1.15); opacity: 0.8; filter: blur(18px); }
            100% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
        }
        @keyframes listen-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 80%, var(--accent-secondary) 20%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.speaking-animation {
            animation: speak-pulse 1s infinite cubic-bezier(0.4, 0, 0.6, 1), speak-color-shift 2.5s infinite alternate;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%; /* More elliptical, "mouth-like" */
            filter: blur(3px) drop-shadow(0 0 40px var(--conversation-indicator));
            opacity: 1;
        }
        .sound-blob.speaking-animation::before,
        .sound-blob.speaking-animation::after {
            animation: speak-ring-pulse 1.3s infinite ease-in-out;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%;
        }

        @keyframes speak-pulse {
            0% { transform: scale(0.98) rotate(0deg); }
            25% { transform: scale(1.05) rotate(3deg); }
            50% { transform: scale(1.02) rotate(-3deg); }
            75% { transform: scale(1.08) rotate(3deg); }
            100% { transform: scale(0.98) rotate(0deg); }
        }
        @keyframes speak-ring-pulse {
            0% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
            50% { transform: scale(1.1); opacity: 0.9; filter: blur(12px); }
            100% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
        }
        @keyframes speak-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 70%, white 30%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.idle-animation {
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
            opacity: 0.6;
            filter: blur(8px) drop-shadow(0 0 20px var(--conversation-indicator));
            transform: scale(0.9);
        }

        .conversation-status-text {
            font-size: 2.2rem; /* Larger */
            font-weight: 800; /* Bolder */
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 2.5em;
            color: var(--text-primary);
            text-shadow: 0 0 10px color-mix(in srgb, var(--conversation-indicator) 50%, transparent); /* Subtle glow */
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .conversation-status-text.listening-state { color: var(--accent-secondary); text-shadow: 0 0 15px var(--accent-secondary); }
        .conversation-status-text.speaking-state { color: var(--accent-primary); text-shadow: 0 0 15px var(--accent-primary); }
        .conversation-status-text.error-state { color: var(--accent-error); text-shadow: 0 0 15px var(--accent-error); }


        .conversation-history-display {
            max-width: 600px; /* Slightly narrower to focus */
            width: 90%; /* Responsive width */
            height: 120px; /* Consistent height */
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 1.5rem; /* More rounded */
            padding: 1.2rem;
            text-align: left; /* Align text left for readability */
            font-size: 1.1rem;
            line-height: 1.6;
            background: linear-gradient(to top, var(--card-bg) 70%, color-mix(in srgb, var(--card-bg) 20%, transparent) 100%); /* Fade out top */
            box-shadow: 0 8px 20px rgba(0,0,0,0.25); /* Stronger shadow */
            color: var(--text-primary);
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
            contain: layout style; /* Performance hint */
        }
        .conversation-history-display::-webkit-scrollbar {
            width: 0;
        }
        .conversation-history-display p { margin-bottom: 0.5rem; }
        .conversation-history-display p:last-child { margin-bottom: 0; }
        .user-utterance { color: var(--user-bubble-text); font-weight: 600; } /* Bolder */
        .ai-utterance { color: var(--ai-bubble-text); font-weight: 600; } /* Bolder */

        .conversation-mic-btn {
            width: 80px; /* Larger button */
            height: 80px;
            margin-top: 3rem !important; /* Push it further down for separation */
            background-color: var(--accent-primary); /* Directly use accent primary for glow effect */
            color: white; /* Ensure icon is white */
            box-shadow: 0 0 15px var(--accent-primary);
        }
        .conversation-mic-btn:hover {
            box-shadow: 0 0 25px var(--accent-primary), 0 0 40px var(--accent-primary-hover);
            transform: scale(1.05);
        }
        .conversation-mic-btn.voice-input-active {
            background-color: var(--accent-error) !important;
            box-shadow: 0 0 20px var(--accent-error), 0 0 35px var(--accent-error), 0 0 50px var(--accent-error);
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        /* Re-define pulse-red to use var(--accent-error) */
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 15px color-mix(in srgb, var(--accent-error) 0%, transparent); } /* Larger pulse */
        }

    </style>
</head>
<body class="antialiased" data-theme="default-dark">

    <!-- Conversation Mode Overlay (NEW SECTION) -->
    <div id="conversation-mode-overlay" class="hidden">
        <button id="conversation-mode-close-btn" aria-label="Close Conversation Mode" title="Close Conversation Mode">
            <span data-lucide="x" class="w-8 h-8"></span>
        </button>

        <div class="conversation-controls">
            <label for="voice-select">Voice:</label>
            <select id="voice-select" aria-label="Select AI Voice" class="p-2 rounded-md border text-sm">
                <option value="">Default Voice</option>
                <!-- Voices will be populated dynamically -->
            </select>

            <label for="personality-select">Personality:</label>
            <select id="personality-select" aria-label="Select AI Personality" class="p-2 rounded-md border text-sm">
                <!-- Personalities will be populated dynamically -->
            </select>
        </div>

        <div class="sound-blob-wrapper">
            <div id="sound-blob" class="sound-blob idle-animation"></div>
        </div>

        <div id="conversation-status-text" class="conversation-status-text">
            Tap the button to start conversing!
        </div>

        <div id="conversation-history-display" class="conversation-history-display">
            <!-- Last few spoken phrases will appear here -->
        </div>

        <button id="conversation-mic-btn" aria-label="Toggle Microphone" class="flex items-center justify-center rounded-full shadow-lg cursor-pointer transition-all duration-300 glow-button conversation-mic-btn">
            <span data-lucide="mic" class="w-8 h-8"></span>
        </button>
    </div>
    <!-- END Conversation Mode Overlay -->

    <!-- Overlay for mobile sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <!-- Sidebar -->
    <aside id="sidebar" class="hidden-mobile">
        <div class="flex items-center justify-between pb-4 border-b border-[var(--sidebar-border)] mb-4">
            <h2 class="text-xl font-bold flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Small AI v2
            </h2>
            <button id="close-sidebar-btn" aria-label="Close Sidebar" title="Close Sidebar" class="md:hidden" style="color: var(--text-secondary); background-color: transparent; border: none;">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>
        </div>

        <!-- New Chat Button -->
        <button id="new-chat-button" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4 glow-button" style="background-color: var(--accent-primary); color: black;">
            <span data-lucide="plus" class="w-5 h-5 mr-2"></span> New Chat
        </button>

        <!-- Previous Chats Section -->
        <div class="flex-1 overflow-y-auto mb-4">
            <h3 class="text-sm font-semibold uppercase" style="color: var(--text-secondary);">Previous Chats</h3>
            <ul id="sidebar-chat-list" class="space-y-1">
                <!-- Chat items will be dynamically loaded here -->
            </ul>
        </div>

        <!-- Theme Selector (Dropdown for different themes) -->
        <div class="mt-auto pt-4 border-t border-[var(--sidebar-border)]">
            <h3 class="text-sm font-semibold uppercase" style="color: var(--text-secondary);">Themes</h3>
            <select id="app-theme-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select App Theme">
                <option value="default">Small AI v2 (Default)</option>
                <option value="celestial-horizon">Celestial Horizon</option>
                <option value="verdant-calm">Verdant Calm</option>
                <option value="cybernetic-pulse">Cybernetic Pulse</option>
                <option value="urban-pulse">Urban Pulse</option>
                <option value="rustic-ember">Rustic Ember</option>
                <option value="neon-mirage">Neon Mirage</option>
                <option value="ivory-bloom">Ivory Bloom</option>
                <option value="obsidian-night">Obsidian Night</option>
                <option value="solar-dawn">Solar Dawn</option>
                <option value="aurora-drift">Aurora Drift</option>
                <option value="timeless-echo">Timeless Echo</option>
                <option value="mystic-void">Mystic Void</option>
                <option value="darkest-bw">The Darkest Night</option>
            </select>
        </div>

        <!-- Version Selector -->
        <div class="mt-4 pt-4 border-t border-[var(--sidebar-border)]">
            <h3 class="text-sm font-semibold uppercase" style="color: var(--text-secondary);">Version</h3>
            <select id="version-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select Chatbot Version">
                <option value="https://mystic-vision-ai-standalone-chatbot.netlify.app/">Main Version</option>
                <option value="https://mystic-vision-ai-lite.netlify.app/">Lite Version</option>
                <option value="https://mystic-vision-ai-basic.netlify.app/">Basic Version</option>
                <option value="https://mystic-vision-ai-mini.netlify.app/">Mini Version</option>
                <option value="https://cosmic-chat-ai-simple-ai-chatbot.netlify.app/">Cosmic Chat AI</option>
                <option value="https://small-ai-big-vision.netlify.app/">Small AI (Legacy)</option>
                <option value="https://small-ai-big-vision-v2.netlify.app/" selected>Small AI v2 (Current)</option>
            </select>
        </div>
    </aside>

    <!-- Main Chat Container -->
    <div id="main-chat-window" class="min-w-0">
        <!-- Header for the chat -->
        <div class="flex justify-between items-center p-4 border-b border-[var(--border-color)]" style="background-color: var(--header-bg);">
            <div class="flex items-center">
                <!-- Hamburger menu button for mobile -->
                <button id="hamburger-menu-button" aria-label="Open Sidebar Menu" title="Open Menu" style="background-color: var(--header-bg); border-color: var(--border-color); color: var(--text-primary);">
                    <span data-lucide="menu" class="w-6 h-6"></span>
                </button>
                <h1 class="text-xl font-bold flex items-center gap-2" style="color: var(--text-primary);">
                    <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Current Chat
                </h1>
            </div>
            <!-- Right side of header -->
            <div class="flex items-center gap-4">
                <!-- Conversation Mode Toggle Button (NEW) -->
                <button id="conversation-mode-toggle-btn" aria-label="Conversation Mode" title="Start Voice Conversation" class="flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="messages-square" class="w-5 h-5"></span>
                </button>
                <!-- Dark Mode Toggle -->
                <div class="flex items-center gap-2">
                    <span class="text-sm" style="color: var(--text-secondary);">Dark Mode</span>
                    <label class="switch relative inline-block w-14 h-8">
                        <input type="checkbox" id="dark-mode-toggle" class="opacity-0 w-0 h-0">
                        <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:rounded-full"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Chat history div with a minimum height and scroll -->
        <div id="chat-history" class="p-4 overflow-y-auto flex-1 flex flex-col">
            <!-- Initial AI message will be appended here by JS -->
        </div>
        
        <!-- Chat input section with attachment, voice and send button -->
        <div id="chat-input-area-container" class="p-4 border-t border-[var(--border-color)] relative transition-all duration-300" style="background-color: var(--header-bg);">
            <!-- Attachment preview -->
            <div id="chat-attachments-preview-container" class="mb-2 flex flex-wrap items-center gap-2 hidden">
                <!-- Attachments previews will be dynamically added here -->
            </div>

            <div class="flex gap-2 items-end flex-wrap">
                <!-- Voice Input Button -->
                <button id="voice-input-btn" aria-label="Voice Input" title="Voice Input (Speech-to-Text)" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="mic" class="w-5 h-5"></span>
                </button>
                
                <!-- Attach File Button -->
                <label for="chat-file-upload" aria-label="Attach File" title="Attach Files" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="paperclip" class="w-5 h-5"></span>
                </label>
                <input type="file" id="chat-file-upload" accept="image/*, .txt, .pdf, .csv, .json, .xml, .md" class="hidden" multiple>

                <textarea id="chat-input" class="flex-1 p-3 rounded-2xl border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm min-w-0 resize-none max-h-[120px] overflow-y-auto" placeholder="Type your message or ask a question..." rows="1" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);"></textarea>
                
                <button id="send-chat-btn" aria-label="Send Message" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-[var(--accent-primary)] transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed glow-button flex-shrink-0" style="background-color: var(--accent-primary); color: white;">
                    <span data-lucide="send" class="w-5 h-5"></span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Temporary message for clipboard copy -->
    <div id="copy-message">Text copied to clipboard!</div>

    <script type="text/javascript">
        // Register Service Worker for PWA capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        const createIcons = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        };

        // DOM elements
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const hamburgerMenuButton = document.getElementById('hamburger-menu-button');

        const mainChatWindow = document.getElementById('main-chat-window');
        const darkModeToggle = document.getElementById('dark-mode-toggle'); // Moved to header, renamed ID for clarity
        const appThemeSelect = document.getElementById('app-theme-select-sidebar'); // New element for theme selection
        const newChatButton = document.getElementById('new-chat-button');
        const chatHistoryDiv = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatFileUpload = document.getElementById('chat-file-upload');
        const chatAttachmentsPreviewContainer = document.getElementById('chat-attachments-preview-container'); 
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const copyMessage = document.getElementById('copy-message');
        const versionSelectSidebar = document.getElementById('version-select-sidebar');
        const sidebarChatList = document.getElementById('sidebar-chat-list');
        const chatInputAreaContainer = document.getElementById('chat-input-area-container'); // Parent for drag/drop

        // NEW: Conversation Mode DOM elements
        const conversationModeOverlay = document.getElementById('conversation-mode-overlay');
        const conversationModeToggleBtn = document.getElementById('conversation-mode-toggle-btn');
        const conversationModeCloseBtn = document.getElementById('conversation-mode-close-btn');
        const voiceSelect = document.getElementById('voice-select');
        const personalitySelect = document.getElementById('personality-select');
        const soundBlob = document.getElementById('sound-blob');
        const conversationStatusText = document.getElementById('conversation-status-text');
        const conversationHistoryDisplay = document.getElementById('conversation-history-display');
        const conversationMicBtn = document.getElementById('conversation-mic-btn');


        const errorContainer = document.createElement('div');
        errorContainer.id = 'error-message';
        errorContainer.classList.add('hidden', 'px-6', 'py-4', 'rounded-xl', 'relative', 'shadow-md', 'my-4', 'fixed', 'top-4', 'left-1/2', '-translate-x-1/2', 'z-50', 'w-11/12', 'max-w-md');
        const errorText = document.createElement('span');
        errorText.id = 'error-text';
        errorText.classList.add('block', 'sm:inline');
        errorContainer.appendChild(errorText);
        document.body.appendChild(errorContainer);

        // --- Global State and Constants ---
        const CHAT_SESSIONS_KEY = 'smallAI_chat_sessions';
        const CURRENT_SESSION_ID_KEY = 'smallAI_current_session_id';
        const THEME_STORAGE_KEY = 'smallAI_selected_theme'; // Stores theme name (e.g., 'celestial-horizon')
        const MODE_STORAGE_KEY = 'smallAI_theme_mode'; // Stores 'dark' or 'light'
        const DEFAULT_THEME_NAME = 'default';
        const DEFAULT_MODE = 'dark';
        const CONVERSATION_VOICE_KEY = 'smallAI_conversation_voice'; // NEW
        const CONVERSATION_PERSONALITY_KEY = 'smallAI_conversation_personality'; // NEW

        let allChatSessions = {}; // Maps session ID to {id, title, history, timestamp}
        let currentSessionId = null;
        let chatAttachments = []; // Array to store {file: File, mimeType: string, data: string} for current chat input

        let currentThemeName = DEFAULT_THEME_NAME;
        let currentMode = DEFAULT_MODE;

        // Web Speech API related variables (for general chat dictation)
        let currentUtterance = null;
        let isSpeaking = false; // Flag for general chat dictation
        let messageTextCache = new Map(); // Store message content for copy/dictate

        // Speech Recognition variables (for general chat voice input)
        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isVoiceInputActive = false; // Flag for general chat voice input
        let finalTranscript = ''; // Stores the accumulated final transcript for speech input

        // NEW: Conversation Mode Specific Variables
        let isConversationModeActive = false;
        let isAiSpeakingInConversation = false;
        let isUserListeningInConversation = false;
        let conversationSpeechRecognition = null; // Separate recognition instance for conversation mode
        let conversationFinalTranscript = '';
        let conversationInterimTranscript = '';
        let availableVoices = [];
        let selectedVoice = null;
        let selectedPersonality = 'Standard'; // Default personality
        let conversationDisplayTimeout = null; // For clearing conversation display


        const personalities = [
            { name: "Standard", prompt: "" },
            { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
            { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
            { name: "Philosophical", prompt: "Respond as a deep-thinking, philosophical AI. Explore underlying meanings and broader implications, using reflective and insightful language." },
            { name: "Curious", prompt: "Respond as an endlessly curious AI, often asking thoughtful follow-up questions to understand better. Show an eagerness to learn." },
            { name: "Humorous", prompt: "Respond as a lighthearted and funny AI, often making clever jokes or witty observations. Keep the mood cheerful." },
            { name: "Formal", prompt: "Respond in a very formal and precise manner. Avoid slang or casual expressions, maintaining a sophisticated and respectful tone." },
            { name: "Casual", prompt: "Respond in a relaxed, informal, and conversational tone, like talking to a friend. Use common idioms and a laid-back style." },
            { name: "Optimistic", prompt: "Respond with an overwhelmingly positive and hopeful outlook. Emphasize solutions and bright possibilities." },
            { name: "Skeptical", prompt: "Respond with a cautious and questioning attitude, often looking for evidence or flaws in arguments. Be analytical and critical." },
            { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
            { name: "Poetic", prompt: "Respond using evocative language, metaphors, and a touch of poetic flair. Let your words flow with rhythm and imagery." },
            { name: "Concise", prompt: "Respond with extreme brevity and to the point, minimizing unnecessary words. Deliver information efficiently." },
            { name: "Verbose", prompt: "Respond with detailed and elaborate explanations, exploring every facet of the topic. Provide rich descriptions and context." },
            { name: "Narrator", prompt: "Respond as if you are narrating a story or documentary, setting a scene or describing events with a captivating voice." },
            { name: "Enthusiastic", prompt: "Respond with high energy and excitement, showing great interest in the conversation. Use exclamation marks and vivid language." },
            { name: "Mysterious", prompt: "Respond with an air of mystery, hinting at deeper knowledge without revealing everything. Be intriguing and slightly enigmatic." },
            { name: "Empathetic", prompt: "Respond with strong understanding and sharing of feelings, focusing on emotional support and validation. Show genuine care." },
            { name: "Analyst", prompt: "Respond like a data analyst, breaking down information, identifying patterns, and drawing logical conclusions based on facts." },
            { name: "Mentor", prompt: "Respond as a seasoned mentor, offering guidance, advice, and a wise perspective to help the user grow." },
            { name: "Dreamer", prompt: "Respond with imaginative and abstract ideas, often exploring fantastical possibilities and creative concepts. Think outside the box." },
            { name: "Strategist", prompt: "Respond by focusing on goals, plans, and optimal ways to achieve objectives. Offer clear, actionable strategies." },
            { name: "Minimalist", prompt: "Respond with the absolute bare minimum of words, almost like a haiku or a very short, impactful statement. Less is more." },
            { name: "Futurist", prompt: "Respond with a focus on future trends, predictions, and the long-term impact of technology and societal changes." },
            { name: "Zen Master", prompt: "Respond calmly, contemplatively, and with a focus on inner peace, mindfulness, and the present moment. Offer tranquil wisdom." }
        ];

        // Initialize SpeechRecognition for general chat if available
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceInputActive = true;
                voiceInputBtn.classList.add('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5');
                chatInput.placeholder = 'Listening... Speak now.';
                finalTranscript = '';
                chatInput.dataset.initialText = chatInput.value;
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript + ' ';
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript + interimTranscript;
                adjustChatInputHeight();
                chatInput.scrollLeft = chatInput.scrollWidth;
            };

            recognition.onend = () => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                
                if (finalTranscript.trim() !== '') {
                    chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript.trim();
                    chatInput.dataset.initialText = chatInput.value;
                } else if (chatInput.value.trim() === (chatInput.dataset.initialText || '').trim()) {
                    // No new speech added, keep existing text.
                } else {
                    chatInput.value = chatInput.dataset.initialText || '';
                }
                adjustChatInputHeight();
            };

            recognition.onerror = (event) => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected, recognition ended.');
                    chatInput.value = chatInput.dataset.initialText || '';
                } else if (event.error === 'network') {
                    showError('Speech recognition network error. This often means a firewall, proxy, or browser extension is blocking access to Google\'s speech services. Please try disabling extensions or testing in incognito mode.');
                } else {
                    showError(`Speech recognition error: ${event.error}`);
                }
                adjustChatInputHeight();
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported in this browser. General Voice input button will be hidden.');
            if (voiceInputBtn) {
                voiceInputBtn.style.display = 'none';
            }
        }

        // NEW: Initialize SpeechRecognition for Conversation Mode
        if (SpeechRecognition) {
            conversationSpeechRecognition = new SpeechRecognition();
            conversationSpeechRecognition.continuous = false; // Listen for a single utterance
            conversationSpeechRecognition.interimResults = true;
            conversationSpeechRecognition.lang = 'en-US';

            conversationSpeechRecognition.onstart = () => {
                isUserListeningInConversation = true;
                updateButtonIcon(conversationMicBtn, 'mic-off', 'w-8 h-8');
                conversationMicBtn.classList.add('voice-input-active');
                updateConversationStatus('Listening...', 'listening');
                conversationFinalTranscript = '';
                conversationInterimTranscript = '';
                clearConversationDisplay();
            };

            conversationSpeechRecognition.onresult = (event) => {
                let interim = '';
                let final = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        final += event.results[i][0].transcript + ' ';
                    } else {
                        interim += event.results[i][0].transcript;
                    }
                }
                conversationFinalTranscript = final;
                conversationInterimTranscript = interim;
                updateConversationDisplay(`<span class="user-utterance">You: ${conversationFinalTranscript}${conversationInterimTranscript}</span>`);
            };

            conversationSpeechRecognition.onend = () => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                
                if (conversationFinalTranscript.trim() !== '') {
                    handleUserSpeechEnd(conversationFinalTranscript.trim());
                } else {
                    updateConversationStatus('No speech detected. Say something!');
                    setSoundBlobState('idle');
                }
            };

            conversationSpeechRecognition.onerror = (event) => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                console.error('Conversation mode Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings to use Conversation Mode.');
                    updateConversationStatus('Microphone access denied.', 'error');
                } else if (event.error === 'no-speech') {
                    updateConversationStatus('No speech detected. Say something!');
                } else {
                    showError(`Conversation mode speech recognition error: ${event.error}`);
                    updateConversationStatus(`Error: ${event.error}`, 'error');
                }
                setSoundBlobState('idle');
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported. Conversation Mode will be limited.');
            if (conversationModeToggleBtn) {
                conversationModeToggleBtn.style.display = 'none';
            }
        }

        // --- Theme Management ---
        function applyTheme(themeName, mode) {
            currentThemeName = themeName;
            currentMode = mode;
            document.body.dataset.theme = `${themeName}-${mode}`;
            localStorage.setItem(THEME_STORAGE_KEY, themeName);
            localStorage.setItem(MODE_STORAGE_KEY, mode);
            darkModeToggle.checked = (mode === 'dark'); // Update toggle based on actual mode
            if (appThemeSelect && appThemeSelect.value !== themeName) {
                appThemeSelect.value = themeName; // Update dropdown
            }
        }

        // Initialize Theme
        const storedThemeName = localStorage.getItem(THEME_STORAGE_KEY) || DEFAULT_THEME_NAME;
        const storedMode = localStorage.getItem(MODE_STORAGE_KEY) || DEFAULT_MODE;
        applyTheme(storedThemeName, storedMode);

        // Event listener for Dark/Light Mode Toggle (in header)
        darkModeToggle.addEventListener('change', () => {
            const newMode = darkModeToggle.checked ? 'dark' : 'light';
            applyTheme(currentThemeName, newMode);
        });

        // Event listener for Theme Selector (in sidebar)
        if (appThemeSelect) {
            appThemeSelect.addEventListener('change', (event) => {
                const newThemeName = event.target.value;
                applyTheme(newThemeName, currentMode); // Apply with current dark/light mode
            });
        }


        // Version Selector Listener
        versionSelectSidebar.addEventListener('change', (event) => {
            const selectedUrl = event.target.value;
            if (selectedUrl && selectedUrl !== window.location.href) {
                window.location.href = selectedUrl;
            }
        });

        // --- Chat History & Session Management ---

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        function loadAllChatSessions() {
            const storedSessions = localStorage.getItem(CHAT_SESSIONS_KEY);
            if (storedSessions) {
                allChatSessions = JSON.parse(storedSessions);
            } else {
                allChatSessions = {};
            }
            renderSidebarChats();
        }

        function saveAllChatSessions() {
            localStorage.setItem(CHAT_SESSIONS_KEY, JSON.stringify(allChatSessions));
        }

        function renderSidebarChats() {
            sidebarChatList.innerHTML = '';
            const sortedSessions = Object.values(allChatSessions).sort((a, b) => b.timestamp - a.timestamp);

            if (sortedSessions.length === 0 && !currentSessionId) {
                createNewChatSession('New Chat'); // Auto-create if no sessions
                return;
            }

            sortedSessions.forEach(session => {
                const li = document.createElement('li');
                li.classList.add('sidebar-chat-item');
                if (session.id === currentSessionId) {
                    li.classList.add('active');
                }
                li.dataset.sessionId = session.id;

                li.innerHTML = `
                    <div class="sidebar-chat-item-content">
                        <span data-lucide="message-square" class="w-5 h-5" style="color: inherit;"></span>
                        <span class="sidebar-chat-item-title" title="${session.title}">${session.title}</span>
                    </div>
                    <div class="sidebar-chat-item-actions">
                        <button class="delete-chat-btn" title="Delete chat">
                            <span data-lucide="trash-2"></span>
                        </button>
                    </div>
                `;
                sidebarChatList.appendChild(li);
            });
            createIcons(); // Render icons in new sidebar elements
        }

        function createNewChatSession(initialTitle = 'New Chat') {
            const newId = generateUniqueId();
            const newSession = {
                id: newId,
                title: initialTitle,
                history: [],
                timestamp: Date.now()
            };
            allChatSessions[newId] = newSession;
            currentSessionId = newId;
            localStorage.setItem(CURRENT_SESSION_ID_KEY, newId);
            saveAllChatSessions();

            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            const initialAIMessageText = 'Hello! I am your AI assistant. How can I assist you today? Feel free to ask questions or attach relevant files for analysis related to Dream11 or any other topic!';
            allChatSessions[newId].history.push({ role: 'model', parts: [{ text: initialAIMessageText }] }); // Add to history
            appendChatMessage('ai', initialAIMessageText); // Display
            
            updateCurrentSessionHistory(); // Save the new session with initial AI message
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); // Hide sidebar on mobile after new chat
            sidebarOverlay.classList.remove('active');
        }

        function loadChatSession(sessionId) {
            if (currentSessionId === sessionId) return; // Already on this chat
            
            const session = allChatSessions[sessionId];
            if (!session) {
                console.error('Session not found:', sessionId);
                showError('Requested chat session not found.');
                return;
            }

            currentSessionId = sessionId;
            localStorage.setItem(CURRENT_SESSION_ID_KEY, sessionId);

            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = []; // Clear attachments from previous unsent input
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            session.history.forEach(msg => {
                // Re-parse and display messages
                if (msg.role === 'user') {
                    let userText = '';
                    const displayAttachments = [];
                    msg.parts.forEach(part => {
                        if (part.text) {
                            userText += part.text + ' ';
                        } else if (part.inlineData) {
                            displayAttachments.push({
                                mimeType: part.inlineData.mimeType,
                                data: part.inlineData.data,
                                name: `attachment_${displayAttachments.length + 1}`
                            });
                        }
                    });
                    appendChatMessage('user', userText.trim(), displayAttachments);
                } else {
                    appendChatMessage('ai', msg.parts[0].text);
                }
            });
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); // Hide sidebar on mobile after loading chat
            sidebarOverlay.classList.remove('active');
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        function updateCurrentSessionHistory(newTitle = null) {
            if (!currentSessionId || !allChatSessions[currentSessionId]) {
                console.error("No active session to update. This should not happen.");
                return;
            }

            // Ensure history is up-to-date and deep-copied if needed (though direct push/pop keeps it consistent now)
            allChatSessions[currentSessionId].timestamp = Date.now();
            if (newTitle) {
                 allChatSessions[currentSessionId].title = newTitle;
            } else if (allChatSessions[currentSessionId].title === 'New Chat' && allChatSessions[currentSessionId].history.length > 1) {
                // Auto-set title from first user message if still default and history exists
                const firstUserMessage = allChatSessions[currentSessionId].history.find(msg => msg.role === 'user' && msg.parts[0]?.text);
                if (firstUserMessage) {
                    allChatSessions[currentSessionId].title = firstUserMessage.parts[0].text.substring(0, 50) + (firstUserMessage.parts[0].text.length > 50 ? '...' : '');
                }
            }
            saveAllChatSessions();
            renderSidebarChats(); // Re-render sidebar to show updated title/timestamp
        }

        function deleteChatSession(sessionIdToDelete) {
            if (confirm('Are you sure you want to delete this chat? This action cannot be undone.')) {
                delete allChatSessions[sessionIdToDelete];
                saveAllChatSessions();
                
                if (currentSessionId === sessionIdToDelete) {
                    currentSessionId = null; // Clear current session if deleted
                    localStorage.removeItem(CURRENT_SESSION_ID_KEY);
                    createNewChatSession(); // Start a new one
                } else {
                    renderSidebarChats(); // Just re-render sidebar
                }
                showCopyMessage('Chat deleted successfully!', `var(--accent-error)`); // Use generic show message
            }
        }

        // --- Utility Functions ---

        // Function to convert a file to a Base64 string and return its MIME type and data
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({
                    mimeType: file.type || 'application/octet-stream', // Fallback MIME type
                    data: reader.result.split(',')[1]
                });
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        // Function to get Lucide icon name based on MIME type
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType === 'application/pdf') return 'file-text';
            if (mimeType.includes('text/')) return 'file-text';
            if (mimeType.includes('csv') || mimeType.includes('excel')) return 'file-spreadsheet';
            if (mimeType.includes('json') || mimeType.includes('xml') || mimeType.includes('code') || mimeType.includes('markdown')) return 'file-code';
            return 'file';
        }

        // Function to display an error message
        function showError(message) {
            errorText.textContent = message;
            errorContainer.classList.remove('hidden');
            setTimeout(() => {
                errorContainer.classList.add('hidden');
            }, 5000); // Hide after 5 seconds
        }
        
        // --- Marked.js Custom Renderer for Code Blocks ---
        const renderer = {
            code(code, lang) {
                let actualCodeContent;
                if (typeof code === 'object' && code !== null && typeof code.text === 'string') {
                    actualCodeContent = code.text;
                } else if (typeof code !== 'string') {
                    actualCodeContent = String(code);
                } else {
                    actualCodeContent = code;
                }

                const languageDisplay = lang ? `<span class="text-xs font-semibold uppercase" style="color: var(--text-secondary);">` + lang + `</span>` : '';
                const uniqueId = `code-block-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                const escapedCode = actualCodeContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                return `
                    <div class="code-block-container" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                        <div class="code-block-header" style="background-color: var(--header-bg); color: var(--text-secondary); border-bottom-color: var(--border-color);">
                            ${languageDisplay}
                            <button class="code-block-copy-button" data-copy-target="${uniqueId}" style="color: var(--text-secondary);">
                                <span data-lucide="clipboard" class="w-4 h-4"></span>
                                Copy code
                            </button>
                        </div>
                        <pre style="color: var(--text-primary);"><code id="${uniqueId}">${escapedCode}</code></pre>
                    </div>
                `;
            }
        };

        marked.use({ renderer });

        /**
         * Helper function to update a Lucide icon displayed within a button.
         * Removes the existing SVG and adds a new span for Lucide to convert.
         * @param {HTMLElement} buttonElement The button element containing the icon.
         * @param {string} newIconName The Lucide icon name (e.g., 'check', 'clipboard').
         * @param {string} [classList] Optional additional classes for the new span. Defaults to 'w-4 h-4' for action buttons.
         */
        function updateButtonIcon(buttonElement, newIconName, classList = 'w-4 h-4') {
            let currentIconSvg = buttonElement.querySelector('.lucide');
            if (currentIconSvg) {
                currentIconSvg.remove();
            }

            const newIconSpan = document.createElement('span');
            newIconSpan.setAttribute('data-lucide', newIconName);
            newIconSpan.className = classList;

            buttonElement.appendChild(newIconSpan);
           
            createIcons();
        }

        // Function to append a message to the chat history
        function appendChatMessage(role, text, attachments = []) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', role);
            
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            messageDiv.dataset.messageId = messageId;
            
            let contentHTML = '';
            let rawMessageContentForCache = '';

            if (role === 'user') {
                rawMessageContentForCache = `You: ${text}`;
                contentHTML += `<span class="font-bold">You:</span> ${text}`;
                if (attachments.length > 0) {
                    contentHTML += `<div class="mt-2 flex flex-wrap gap-2">`;
                    attachments.forEach(attachment => {
                        if (attachment.mimeType.startsWith('image/')) {
                            contentHTML += `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name || 'User attachment'}" class="chat-image w-24 h-24 object-cover">`;
                        } else {
                            contentHTML += `
                                <div class="flex items-center space-x-1 p-2 rounded-md text-sm" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                                    <span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-4 h-4 flex-shrink-0" style="color: var(--accent-secondary);"></span>
                                    <span class="truncate max-w-[120px]">${attachment.name || 'File'}</span>
                                </div>
                            `;
                        }
                    });
                    contentHTML += `</div>`;
                    rawMessageContentForCache += `\n[Attachments: ${attachments.map(a => a.name).join(', ')}]`;
                }
            } else { // AI message
                rawMessageContentForCache = `AI: ${text}`;
                contentHTML = `<div class="message-content">${marked.parse(text)}</div>`;
            }
            
            messageTextCache.set(messageId, rawMessageContentForCache); 

            const actionsHTML = `
                <div class="message-actions">
                    <button class="copy-message-btn" title="Copy message" data-message-id="${messageId}">
                        <span data-lucide="clipboard" class="w-4 h-4"></span>
                    </button>
                    <button class="dictate-message-btn" title="Dictate message" data-message-id="${messageId}">
                        <span data-lucide="volume-2" class="w-4 h-4"></span>
                    </button>
                </div>
            `;
            
            messageDiv.innerHTML = contentHTML + actionsHTML;
            chatHistoryDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.transform = 'scale(1)';
            }, 10);
            
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            createIcons();
        }
        
        // Event listener for chat file upload
        chatFileUpload.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // Helper function to process files from various sources (drag/drop, paste, file input)
        async function processFiles(files) {
            for (const file of files) {
                const allowedTypes = [
                    'image/', 'text/', 'application/pdf',
                    'application/json', 'text/csv', 'application/xml', 'text/markdown'
                ];
                const isAllowed = allowedTypes.some(type => file.type.startsWith(type)) || file.name.endsWith('.md');

                if (isAllowed) {
                    try {
                        const { mimeType, data } = await fileToBase64(file);
                        chatAttachments.push({ file, mimeType, data, name: file.name });
                    } catch (error) {
                        showError(`Failed to read chat file ${file.name}.`);
                        console.error('Chat file read error:', error);
                    }
                } else {
                    showError(`File type not supported for chat: ${file.name} (${file.type}).`);
                }
            }
            displayChatAttachments();
            adjustChatInputHeight();
        }

        // Function to display chat attachments
        function displayChatAttachments() {
            chatAttachmentsPreviewContainer.innerHTML = '';
            if (chatAttachments.length > 0) {
                chatAttachmentsPreviewContainer.classList.remove('hidden');
                chatAttachments.forEach((attachment, index) => {
                    const attachmentDiv = document.createElement('div');
                    attachmentDiv.classList.add('chat-attachment-preview-item');
                    attachmentDiv.dataset.index = index;

                    let previewContent = '';
                    if (attachment.mimeType.startsWith('image/')) {
                        previewContent = `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name}" class="w-8 h-8 object-cover rounded-md">`;
                    } else {
                        previewContent = `<span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-5 h-5 flex-shrink-0"></span>`;
                    }

                    attachmentDiv.innerHTML = `
                        ${previewContent}
                        <span class="truncate max-w-[100px]">${attachment.name}</span>
                        <button class="remove-attachment-btn">
                            <span data-lucide="x" class="w-4 h-4"></span>
                        </button>
                    `;
                    chatAttachmentsPreviewContainer.appendChild(attachmentDiv);
                });
                createIcons();
            } else {
                chatAttachmentsPreviewContainer.classList.add('hidden');
            }
        }

        // Event listener for removing individual chat attachments (using event delegation)
        chatAttachmentsPreviewContainer.addEventListener('click', (event) => {
            const removeBtn = event.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const attachmentDiv = removeBtn.closest('[data-index]');
                if (attachmentDiv) {
                    const index = parseInt(attachmentDiv.dataset.index);
                    chatAttachments.splice(index, 1);
                    displayChatAttachments();
                    chatInput.focus();
                }
            }
        });

        // Adjust chat input textarea height dynamically
        function adjustChatInputHeight() {
            chatInput.style.height = 'auto';
            chatInput.style.height = chatInput.scrollHeight + 'px';
        }
        chatInput.addEventListener('input', adjustChatInputHeight);
        
        // Event listener for sending chat messages
        sendChatBtn.addEventListener('click', async () => {
            const userMessage = chatInput.value.trim();
            if (!userMessage && chatAttachments.length === 0) {
                return;
            }
            
            // Stop speech recognition if active before sending
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            const userParts = [];
            if (userMessage) {
                userParts.push({ text: userMessage });
            }
            for (const attachment of chatAttachments) {
                userParts.push({
                    inlineData: {
                        mimeType: attachment.mimeType,
                        data: attachment.data
                    }
                });
            }

            // Use the actual session history directly
            const currentSessionHistory = allChatSessions[currentSessionId].history;

            currentSessionHistory.push({ role: 'user', parts: userParts });
            appendChatMessage('user', userMessage, chatAttachments);
            
            // Clear input and attachment after sending
            chatInput.value = '';
            chatInput.dataset.initialText = ''; // Clear initial text for voice input
            adjustChatInputHeight();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            
            sendChatBtn.disabled = true;
            
            const loadingMessage = document.createElement('div');
            loadingMessage.id = 'chat-loading';
            loadingMessage.classList.add('p-4', 'text-center', 'text-sm');
            loadingMessage.style.color = 'var(--text-secondary)'; /* Themed */
            loadingMessage.innerHTML = `
                <div class="loader-container h-8">
                    <div class="loader-dot"></div>
                    <div class="loader-dot"></div>
                    <div class="loader-dot"></div>
                </div>
                <span class="mt-2 block">AI is typing...</span>
            `;
            chatHistoryDiv.appendChild(loadingMessage);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            try {
                const payload = {
                    contents: currentSessionHistory, // Send the updated history including the latest user message
                };
                
                const responseText = await callGeminiAPI(payload, selectedPersonality); // Pass personality
                
                // Add AI response to the history after successful API call
                currentSessionHistory.push({ role: 'model', parts: [{ text: responseText }] });
                appendChatMessage('ai', responseText);
                
                updateCurrentSessionHistory(); // Persist the updated chat history
                
            } catch (error) {
                console.error('Chat API call failed:', error);
                showError(`An error occurred in the chat: ${error.message}`);
                // If API call fails, remove the last user message from history for re-try
                currentSessionHistory.pop(); 
                updateCurrentSessionHistory(); // Persist the state after pop
            } finally {
                sendChatBtn.disabled = false;
                const loadingDiv = document.getElementById('chat-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }
                chatInput.focus();
            }
        });
        
        // Add event listener for the 'Enter' key on the chat input
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatBtn.click();
            }
        });

        // Event listener for voice input button (general chat)
        voiceInputBtn.addEventListener('click', () => {
            if (recognition) {
                if (isVoiceInputActive) {
                    recognition.stop();
                } else {
                    finalTranscript = ''; // Reset transcript for a new session
                    recognition.start();
                }
            } else {
                showError('Speech recognition is not supported in this browser.');
            }
        });

        // Drag and Drop for Chat Input Area
        chatInputAreaContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.add('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');

            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // Paste files onto the text input box
        chatInput.addEventListener('paste', async (event) => {
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            let filesToProcess = [];
            let textToPaste = '';

            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        filesToProcess.push(file);
                    }
                } else if (item.kind === 'string' && item.type === 'text/plain') {
                    // Get text content, but don't prevent default yet
                    item.getAsString(s => textToPaste = s);
                }
            }

            if (filesToProcess.length > 0) {
                event.preventDefault(); // Prevent default text paste if files are being handled
                await processFiles(filesToProcess);
                // If there was also text content in the paste, append it after processing files
                if (textToPaste) {
                    chatInput.value += textToPaste;
                }
                adjustChatInputHeight();
            }
            // If only text was pasted, the default paste behavior already handled it.
        });


        // Event listener for the New Chat button in sidebar
        newChatButton.addEventListener('click', () => {
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }
            // NEW: Stop conversation mode if active
            if (isConversationModeActive) {
                stopConversationMode();
            }
            createNewChatSession();
        });
        
        // Function to show a temporary message for clipboard copy
        function showCopyMessage(message = 'Text copied to clipboard!', bgColor = 'var(--accent-success)') {
            copyMessage.textContent = message;
            copyMessage.style.backgroundColor = bgColor;
            copyMessage.classList.add('show');
            setTimeout(() => {
                copyMessage.classList.remove('show');
            }, 3000);
        }

        // Event delegation for copy code buttons within chat history
        chatHistoryDiv.addEventListener('click', (event) => {
            const codeCopyButton = event.target.closest('.code-block-copy-button');
            if (codeCopyButton) {
                const targetId = codeCopyButton.dataset.copyTarget;
                const codeElement = document.getElementById(targetId);
                if (codeElement) {
                    const codeToCopy = codeElement.textContent;
                    updateButtonIcon(codeCopyButton, 'check', 'w-4 h-4');
                    copyToClipboard(codeToCopy); 
                    setTimeout(() => {
                        updateButtonIcon(codeCopyButton, 'clipboard', 'w-4 h-4');
                    }, 2000);
                    return;
                }
            }

            const chatCopyButton = event.target.closest('.copy-message-btn');
            if (chatCopyButton) {
                const messageId = chatCopyButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    updateButtonIcon(chatCopyButton, 'check');
                    copyToClipboard(messageContent); 
                    setTimeout(() => {
                        updateButtonIcon(chatCopyButton, 'clipboard');
                    }, 2000);
                } else {
                    showError('Message content not found for copying.');
                }
                return;
            }

            const dictateButton = event.target.closest('.dictate-message-btn');
            if (dictateButton) {
                const messageId = dictateButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    toggleSpeech(messageContent, dictateButton);
                } else {
                    showError('Message content not found for dictation.');
                }
                return;
            }
        });

        // Event delegation for sidebar chat items
        sidebarChatList.addEventListener('click', (event) => {
            const chatItem = event.target.closest('.sidebar-chat-item');
            if (chatItem) {
                const sessionId = chatItem.dataset.sessionId;
                const deleteBtn = event.target.closest('.delete-chat-btn');

                if (deleteBtn) {
                    event.stopPropagation(); // Prevent loading chat when deleting
                    deleteChatSession(sessionId);
                } else {
                    loadChatSession(sessionId);
                }
            }
        });

        // Hamburger menu for mobile sidebar
        hamburgerMenuButton.addEventListener('click', () => {
            sidebar.classList.remove('hidden-mobile');
            sidebarOverlay.classList.add('active');
        });

        closeSidebarBtn.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });

        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });


        // Helper function to copy text to clipboard
        function copyToClipboard(text) { 
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopyMessage();
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        showError('Failed to copy text. Please copy manually.');
                    });
            } else {
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    showCopyMessage();
                } catch (err) {
                    console.error('Failed to copy (fallback):', err);
                    showError('Failed to copy text. Please copy manually.');
                }
                document.body.removeChild(tempTextArea);
            }
        }

        // Helper function for text-to-speech (general chat dictation)
        function toggleSpeech(text, buttonElement) {
            if (!window.speechSynthesis) {
                showError('Speech synthesis not supported in this browser.');
                return;
            }

            if (isSpeaking && currentUtterance && currentUtterance.text === text) {
                if (window.speechSynthesis.paused) {
                    window.speechSynthesis.resume();
                    updateButtonIcon(buttonElement, 'pause');
                } else {
                    window.speechSynthesis.pause();
                    updateButtonIcon(buttonElement, 'volume-2');
                }
            } else {
                startSpeech(text, buttonElement);
            }
        }

        function startSpeech(text, buttonElement) {
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }

            document.querySelectorAll('.dictate-message-btn').forEach(btn => {
                if (btn !== buttonElement) {
                    updateButtonIcon(btn, 'volume-2'); 
                }
            });

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';

            utterance.onstart = () => {
                isSpeaking = true;
                currentUtterance = utterance;
                updateButtonIcon(buttonElement, 'pause');
            };
            utterance.onend = () => {
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };
            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                showError('Failed to dictate message. Check console for details.');
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };

            window.speechSynthesis.speak(utterance);
        }

        // Generic API call function with exponential backoff
        async function callGeminiAPI(payload, personalityName = "Standard") {
            // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            // IMPORTANT: Replace "YOUR_GEMINI_API_KEY" with your actual Google Gemini API Key.
            // Get your API key from Google AI Studio: https://makersuite.google.com/
            // Do NOT expose your API key directly in production applications.
            // For production, consider using a backend proxy to secure your API key.
            // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            const apiKey = "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA"; 

            if (apiKey === "YOUR_GEMINI_API_KEY" || !apiKey || apiKey === "") { 
                throw new Error("API Key is not set or is the default placeholder. Please replace 'YOUR_GEMINI_API_KEY' in the script with your actual Gemini API key.");
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            let response;
            let result;
            let success = false;
            let retryCount = 0;
            const maxRetries = 3;
            let delay = 1000;

            // NEW: Apply personality prompt
            const selectedPersonalityObj = personalities.find(p => p.name === personalityName);
            if (selectedPersonalityObj && selectedPersonalityObj.prompt) {
                // Prepend a system message for personality
                // Note: The prompt is added to the *first* content part of the *first* message in the turn.
                // If `payload.contents` is empty or the first part is not text, this might need adjustment.
                if (payload.contents && payload.contents.length > 0 && payload.contents[0].parts && payload.contents[0].parts.length > 0 && payload.contents[0].parts[0].text) {
                    payload.contents[0].parts[0].text = selectedPersonalityObj.prompt + "\n" + payload.contents[0].parts[0].text;
                } else {
                    // Fallback for empty or non-text first message, though typically the first message is a user's text.
                    payload.contents = [{ role: "user", parts: [{ text: selectedPersonalityObj.prompt }] }].concat(payload.contents);
                }
            }


            while (retryCount < maxRetries && !success) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        if (retryCount < maxRetries - 1) {
                            console.warn(`API rate limit exceeded. Retrying in ${delay / 1000}s...`);
                            await new Promise(res => setTimeout(res, delay));
                            delay *= 2;
                            retryCount++;
                        } else {
                            throw new Error('API rate limit exceeded. Please try again later.');
                        }
                    } else if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
                    } else {
                        result = await response.json();
                        success = true;
                    }
                } catch (err) {
                    if (retryCount < maxRetries - 1) {
                        console.warn(`Fetch error: ${err.message}. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        retryCount++;
                    } else {
                        throw err;
                    }
                }
            }
            
            if (result && result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error('Failed to get a valid response from the AI. No candidates found or content is empty.');
            }
        }


        // --- NEW: Conversation Mode Functions ---

        function updateVoiceDropdown() {
            availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en')); // Filter for English voices
            voiceSelect.innerHTML = '<option value="">Default Voice</option>';
            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                voiceSelect.appendChild(option);
            });
            // Try to set previously selected voice
            const storedVoiceName = localStorage.getItem(CONVERSATION_VOICE_KEY);
            if (storedVoiceName) {
                voiceSelect.value = storedVoiceName;
                selectedVoice = availableVoices.find(v => v.name === storedVoiceName) || null;
            }
        }

        function updatePersonalityDropdown() {
            personalitySelect.innerHTML = '';
            personalities.forEach(p => {
                const option = document.createElement('option');
                option.value = p.name;
                option.textContent = p.name;
                personalitySelect.appendChild(option);
            });
            // Try to set previously selected personality
            const storedPersonalityName = localStorage.getItem(CONVERSATION_PERSONALITY_KEY);
            if (storedPersonalityName && personalities.some(p => p.name === storedPersonalityName)) {
                personalitySelect.value = storedPersonalityName;
                selectedPersonality = storedPersonalityName;
            } else {
                personalitySelect.value = "Standard";
                selectedPersonality = "Standard";
            }
        }

        voiceSelect.addEventListener('change', () => {
            const voiceName = voiceSelect.value;
            selectedVoice = availableVoices.find(v => v.name === voiceName) || null;
            localStorage.setItem(CONVERSATION_VOICE_KEY, voiceName);
        });

        personalitySelect.addEventListener('change', () => {
            selectedPersonality = personalitySelect.value;
            localStorage.setItem(CONVERSATION_PERSONALITY_KEY, selectedPersonality);
            // Optionally, the AI could acknowledge personality change, but for now, it's silent.
        });


        function startConversationMode() {
            if (!SpeechRecognition || !window.speechSynthesis) {
                showError("Your browser doesn't fully support Web Speech APIs needed for Conversation Mode.");
                return;
            }
            isConversationModeActive = true;
            conversationModeOverlay.classList.remove('hidden'); // Use hidden class for visibility
            conversationModeOverlay.classList.add('active');
            document.body.style.overflow = 'hidden'; // Prevent scrolling background
            
            // Stop any ongoing general chat speech or recognition
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            // Start listening for the user
            startConversationListening();
        }

        function stopConversationMode() {
            isConversationModeActive = false;
            conversationModeOverlay.classList.remove('active');
            // Give it a moment for animation before adding 'hidden'
            setTimeout(() => {
                conversationModeOverlay.classList.add('hidden');
                document.body.style.overflow = ''; // Restore scrolling
            }, 300); 

            // Stop any ongoing conversation speech or recognition
            if (isAiSpeakingInConversation) {
                window.speechSynthesis.cancel();
                isAiSpeakingInConversation = false;
            }
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop();
                isUserListeningInConversation = false;
            }
            setSoundBlobState('idle');
            conversationStatusText.textContent = 'Tap the button to start conversing!';
            clearConversationDisplay();
        }

        function startConversationListening() {
            if (!isConversationModeActive || isAiSpeakingInConversation || isUserListeningInConversation) return;

            // Clear any lingering speech
            window.speechSynthesis.cancel();

            // Clear previous transcripts
            conversationFinalTranscript = '';
            conversationInterimTranscript = '';
            clearConversationDisplay();

            // Start recognition
            try {
                conversationSpeechRecognition.start();
                updateConversationStatus('Listening...', 'listening');
                setSoundBlobState('listening');
            } catch (error) {
                if (error.name === 'InvalidStateError') {
                    // Already started, or some other state issue, try stopping then starting
                    conversationSpeechRecognition.stop();
                    setTimeout(() => { // Give it a moment to stop cleanly
                        conversationSpeechRecognition.start();
                        updateConversationStatus('Listening...', 'listening');
                        setSoundBlobState('listening');
                    }, 100);
                } else {
                    console.error("Error starting conversation recognition:", error);
                    showError("Could not start microphone. Please check permissions.");
                    updateConversationStatus("Error starting microphone.", 'error');
                    setSoundBlobState('idle');
                }
            }
        }

        // Handles user finishing speaking
        async function handleUserSpeechEnd(userText) {
            updateConversationStatus('Thinking...', 'thinking');
            setSoundBlobState('idle'); // Stop listening animation

            // Add user message to regular chat history
            const currentSessionHistory = allChatSessions[currentSessionId].history;
            currentSessionHistory.push({ role: 'user', parts: [{ text: userText }] });
            appendChatMessage('user', userText); // Display in background chat
            updateCurrentSessionHistory();

            // Update conversation display
            updateConversationDisplay(`<span class="user-utterance">You: ${userText}</span>`);

            try {
                const payload = {
                    contents: currentSessionHistory,
                };
                const aiResponse = await callGeminiAPI(payload, selectedPersonality);

                // Add AI response to regular chat history
                currentSessionHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                appendChatMessage('ai', aiResponse); // Display in background chat
                updateCurrentSessionHistory();

                startConversationSpeaking(aiResponse);

            } catch (error) {
                console.error("Error in conversation mode API call:", error);
                showError(`AI communication error: ${error.message}`);
                updateConversationStatus("AI communication error. Please try again.", 'error');
                // Remove the user's last message from history if AI failed to respond
                currentSessionHistory.pop();
                updateCurrentSessionHistory();
                setSoundBlobState('idle');
                // Attempt to restart listening after a short delay for error
                setTimeout(startConversationListening, 2000);
            }
        }

        // Handles AI speaking
        function startConversationSpeaking(text) {
            if (!isConversationModeActive) return;

            // Ensure recognition is stopped
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop(); // This will trigger onend
            }
            
            // Clear conversation display to show AI thinking/speaking state
            clearConversationDisplay(); 

            updateConversationStatus('AI Speaking...', 'speaking');
            setSoundBlobState('speaking');
            updateConversationDisplay(`<span class="ai-utterance">AI: ${text}</span>`); // Display AI response immediately

            const utterance = new SpeechSynthesisUtterance(text);
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            utterance.lang = 'en-US'; // Ensure consistent language

            utterance.onstart = () => {
                isAiSpeakingInConversation = true;
                // console.log("AI Started Speaking");
            };

            utterance.onend = () => {
                isAiSpeakingInConversation = false;
                // console.log("AI Finished Speaking");
                // After AI finishes, restart listening for user
                handleAiSpeechEnd();
            };

            utterance.onerror = (event) => {
                console.error('Conversation mode Speech synthesis error:', event.error);
                showError('AI could not speak this message.');
                updateConversationStatus('AI speech error.', 'error');
                isAiSpeakingInConversation = false;
                handleAiSpeechEnd(); // Still try to resume conversation
            };

            window.speechSynthesis.speak(utterance);
        }

        // Handles AI finishing speaking (or error during speaking)
        function handleAiSpeechEnd() {
            if (!isConversationModeActive) return;

            isAiSpeakingInConversation = false;
            updateConversationStatus('Listening...', 'listening');
            setSoundBlobState('listening');
            startConversationListening(); // Restart listening for user input
        }

        // Update conversation display (for current turn)
        function updateConversationDisplay(text) {
            // Clear previous timeout if it exists
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
            }
            conversationHistoryDisplay.innerHTML = `<p>${text}</p>`;
            conversationHistoryDisplay.scrollTop = conversationHistoryDisplay.scrollHeight;
            
            // Set a timeout to clear the display after a short while, to make it feel more ephemeral
            conversationDisplayTimeout = setTimeout(() => {
                clearConversationDisplay();
            }, 5000); // Clear after 5 seconds
        }

        function clearConversationDisplay() {
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
                conversationDisplayTimeout = null;
            }
            conversationHistoryDisplay.innerHTML = '';
        }


        function updateConversationStatus(message, state = 'idle') {
            conversationStatusText.textContent = message;
            conversationStatusText.classList.remove('listening-state', 'speaking-state', 'error-state');
            if (state === 'listening') {
                conversationStatusText.classList.add('listening-state');
            } else if (state === 'speaking') {
                conversationStatusText.classList.add('speaking-state');
            } else if (state === 'error') {
                conversationStatusText.classList.add('error-state');
            }
        }

        function setSoundBlobState(state) {
            soundBlob.classList.remove('listening-animation', 'speaking-animation', 'idle-animation');
            // Ensure pseudo-elements are also reset or controlled by the main class
            // No direct control needed for pseudo-elements if they inherit animation.
            switch (state) {
                case 'listening':
                    soundBlob.classList.add('listening-animation');
                    break;
                case 'speaking':
                    soundBlob.classList.add('speaking-animation');
                    break;
                case 'idle':
                default:
                    soundBlob.classList.add('idle-animation');
                    break;
            }
        }

        // Event listener for conversation mode toggle button
        conversationModeToggleBtn.addEventListener('click', startConversationMode);

        // Event listener for conversation mode close button
        conversationModeCloseBtn.addEventListener('click', stopConversationMode);

        // Event listener for conversation mic button
        conversationMicBtn.addEventListener('click', () => {
            if (isAiSpeakingInConversation) {
                // If AI is speaking, interrupt it
                window.speechSynthesis.cancel();
                // TTS onend will handle restarting listening
            } else if (isUserListeningInConversation) {
                // If user is speaking, stop listening
                conversationSpeechRecognition.stop();
            } else {
                // If idle, start listening
                startConversationListening();
            }
        });

        // Event for when voices are loaded/changed
        window.speechSynthesis.onvoiceschanged = updateVoiceDropdown;

        // --- Initial Load ---
        window.addEventListener('load', () => {
            createIcons();
            loadAllChatSessions();

            let storedSessionId = localStorage.getItem(CURRENT_SESSION_ID_KEY);
            if (storedSessionId && allChatSessions[storedSessionId]) {
                loadChatSession(storedSessionId);
            } else if (Object.keys(allChatSessions).length > 0) {
                // If no specific session, load the most recent one
                const mostRecentSessionId = Object.values(allChatSessions).sort((a,b) => b.timestamp - a.timestamp)[0].id;
                loadChatSession(mostRecentSessionId);
            } else {
                createNewChatSession('New Chat');
            }

            // Set the correct selected option for the version selector on load
            const currentUrl = window.location.href;
            let foundVersionOption = false;
            Array.from(versionSelectSidebar.options).forEach(option => {
                // Check if option value is a substring of current URL to match netlify subdomains
                if (currentUrl.includes(option.value) && option.value.includes('small-ai-big-vision-v2.netlify.app')) {
                    option.selected = true;
                    foundVersionOption = true;
                }
            });
            if (!foundVersionOption && versionSelectSidebar.options.length > 0) {
                // If current version not found or no stored URL, fallback to the explicitly selected option
                // which is "Small AI v2 (Current)" in the HTML.
                // Or if that fails, default to the first available option.
                const preselectedOption = Array.from(versionSelectSidebar.options).find(option => option.selected);
                if (!preselectedOption) {
                    versionSelectSidebar.options[0].selected = true; 
                }
            }

            // Set the correct selected option for the APP theme selector on load
            if (appThemeSelect && localStorage.getItem(THEME_STORAGE_KEY)) {
                appThemeSelect.value = localStorage.getItem(THEME_STORAGE_KEY);
            } else if (appThemeSelect && appThemeSelect.options.length > 0) {
                appThemeSelect.value = DEFAULT_THEME_NAME; // Default to 'default' if nothing stored
            }

            // NEW: Initialize conversation mode dropdowns
            updateVoiceDropdown();
            updatePersonalityDropdown();
            setSoundBlobState('idle'); // Initial state for sound blob

            adjustChatInputHeight(); // Adjust initial input height
        });
    </script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: manifest.json ---

{
    "name": "Small AI v2",
    "short_name": "Small AI v2",
    "description": "An AI Chatbot with powerful features and customizable themes.",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#110B1D",
    "theme_color": "#9400D3",
    "icons": [
        {
            "src": "logo.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "logo.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "logo.png",
            "sizes": "180x180",
            "type": "image/png",
            "purpose": "apple touch icon"
        },
        {
            "src": "logo.png",
            "sizes": "150x150",
            "type": "image/png",
            "purpose": "maskable"
        }
    ],
    "orientation": "portrait"
}

--- END FILE: manifest.json ---

--- START FILE: sw.js ---

const CACHE_NAME = 'small-ai-v2-cache-v1.3'; // Increment this version number when you make significant changes to cached assets!
const urlsToCache = [
    '/', // The root HTML page
    'index.html', // The specific HTML file
    'manifest.json',
    'logo.png', // The application icon

    // External CDN resources - crucial for offline functionality
    'https://cdn.tailwindcss.com',
    'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap',
    'https://cdn.jsdelivr.net/npm/marked/marked.min.js',
    'https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js',
    'https://unpkg.com/lucide@latest'
];

// Install event: caches all defined static assets
self.addEventListener('install', (event) => {
    console.log('Service Worker: Installing and caching static assets...');
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => {
                return cache.addAll(urlsToCache);
            })
            .catch((error) => {
                console.error('Service Worker: Cache.addAll failed', error);
            })
    );
});

// Activate event: cleans up old caches, ensuring only the current version is active
self.addEventListener('activate', (event) => {
    console.log('Service Worker: Activating and cleaning old caches...');
    event.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => {
                    if (cacheName !== CACHE_NAME) {
                        console.log('Service Worker: Deleting old cache:', cacheName);
                        return caches.delete(cacheName);
                    }
                    return null;
                })
            );
        }).then(() => {
            // Ensure the service worker takes control of clients immediately
            return self.clients.claim();
        })
    );
});

// Fetch event: intercepts network requests
self.addEventListener('fetch', (event) => {
    // We only want to handle GET requests for static assets that we can cache.
    // Dynamic API requests (like Gemini's generateContent) should always go to the network
    // and are typically POST requests, so they won't be affected by this caching strategy.
    
    // Convert the request URL to a URL object for easier comparison
    const requestUrl = new URL(event.request.url);

    // Check if the request is for a file we intend to cache
    // This includes both local files and CDN resources
    const isCacheableAsset = urlsToCache.some(url => {
        // For root path and index.html, compare href directly
        if (url === '/' || url === 'index.html') {
            return requestUrl.pathname === '/' || requestUrl.pathname === '/index.html';
        }
        // For other local assets (like manifest.json, logo.png), compare paths
        if (!url.startsWith('http')) {
            return requestUrl.pathname === `/${url}`;
        }
        // For CDN assets, check if the request URL starts with the cached URL
        return requestUrl.href.startsWith(url);
    });

    if (event.request.method === 'GET' && isCacheableAsset) {
        event.respondWith(
            caches.match(event.request)
                .then((response) => {
                    // Cache hit - return cached response
                    if (response) {
                        console.log('Service Worker: Serving from cache:', event.request.url);
                        return response;
                    }
                    // No cache hit - fetch from network
                    console.log('Service Worker: Fetching from network:', event.request.url);
                    return fetch(event.request)
                        .then((networkResponse) => {
                            // If we get a valid response, clone it and put it in cache
                            if (networkResponse && networkResponse.ok) {
                                const responseToCache = networkResponse.clone();
                                caches.open(CACHE_NAME).then((cache) => {
                                    cache.put(event.request, responseToCache);
                                });
                            }
                            return networkResponse;
                        })
                        .catch((error) => {
                            // If network fails and no cached response, log error
                            console.error('Service Worker: Fetch failed for:', event.request.url, error);
                            // Optionally, serve an offline fallback page here for critical assets
                            // For a chat app, if the main HTML can't load, a basic offline message is useful.
                            // If you have a specific offline.html, you can return caches.match('/offline.html');
                            // For simplicity, we'll just return a basic "You're offline" response.
                            return new Response('<h1>You are offline!</h1><p>It looks like you\'re not connected to the internet.</p>', {
                                headers: { 'Content-Type': 'text/html' }
                            });
                        });
                })
        );
    } else {
        // For all other requests (e.g., POST requests, API calls, unlisted assets), go straight to the network
        event.respondWith(fetch(event.request));
    }
});

--- END FILE: sw.js ---

-------------------------------------------------------------------------------------------

CONTEXT 2 : 

--- START FILE: .gitignore ---

# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# generated native folders
/ios
/android


--- END FILE: .gitignore ---

--- START FILE: App.js ---

// App.js

import 'react-native-gesture-handler'; // Must be at the top for React Navigation
import React from 'react';
import { StatusBar, StyleSheet, View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import AppNavigator from './src/navigation/AppNavigator';
import { ThemeProvider } from './src/context/ThemeContext';
import { ChatProvider } from './src/context/ChatContext';

export default function App() {
  return (
    <ThemeProvider>
      <ChatProvider>
        <NavigationContainer>
          <View style={styles.container}>
            <StatusBar translucent backgroundColor="transparent" barStyle="dark-content" />
            <AppNavigator />
          </View>
        </NavigationContainer>
      </ChatProvider>
    </ThemeProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

--- END FILE: App.js ---

--- START FILE: app.json ---

{
  "expo": {
    "name": "Small AI v2",
    "slug": "small-ai-v2-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/logo.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#110B1D"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.smallaiv2",
      "infoPlist": {
        "NSMicrophoneUsageDescription": "This app needs access to your microphone for voice input and conversation mode."
      }
    },
    "android": {
      "permissions": [
        "RECORD_AUDIO",
        "CAMERA",
        "READ_EXTERNAL_STORAGE",
        "WRITE_EXTERNAL_STORAGE"
      ],
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#110B1D"
      },
      "package": "com.yourcompany.smallaiv2"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      // No "react-native-voice" here as per the previous fix attempts
    ]
  }
}

--- END FILE: app.json ---

--- START FILE: babel.config.js ---

// babel.config.js

module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      'react-native-reanimated/plugin', // THIS IS IMPORTANT FOR REANIMATED
      // We will explicitly add the react-native-voice plugin here if it still fails
    ],
  };
};

--- END FILE: babel.config.js ---

--- START FILE: index.js ---

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


--- END FILE: index.js ---

--- START FILE: package.json ---

{
  "name": "smallai_reactnative_app",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-community/masked-view": "^0.1.11",
    "@react-native-picker/picker": "^2.11.2",
    "@react-native-voice/voice": "^3.2.4",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/stack": "^7.4.8",
    "babel-preset-expo": "^54.0.2",
    "expo": "~54.0.9",
    "expo-clipboard": "^8.0.7",
    "expo-document-picker": "~14.0.7",
    "expo-image-picker": "~17.0.8",
    "expo-speech": "~14.0.7",
    "expo-status-bar": "~3.0.8",
    "react": "19.1.0",
    "react-native": "0.81.4",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-markdown-display": "^7.0.2",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0"
  },
  "private": true
}


--- END FILE: package.json ---

--- START FILE: .expo\devices.json ---

{
  "devices": []
}


--- END FILE: .expo\devices.json ---

--- START FILE: .expo\README.md ---

> Why do I have a folder named ".expo" in my project?

The ".expo" folder is created when an Expo project is started using "expo start" command.

> What do the files contain?

- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "packager-info.json": contains port numbers and process PIDs that are used to serve the application to the mobile device/simulator.
- "settings.json": contains the server configuration that is used to serve the application manifest.

> Should I commit the ".expo" folder?

No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.

Upon project creation, the ".expo" folder is already added to your ".gitignore" file.


--- END FILE: .expo\README.md ---

--- START FILE: .expo\settings.json ---

{
  "hostType": "lan",
  "lanType": "ip",
  "dev": true,
  "minify": false,
  "urlRandomness": null,
  "https": false
}


--- END FILE: .expo\settings.json ---

--- START FILE: android\.gitignore ---

# OSX
#
.DS_Store

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# Bundle artifacts
*.jsbundle


--- END FILE: android\.gitignore ---

--- START FILE: android\build.gradle ---

// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
  repositories {
    google()
    mavenCentral()
  }
  dependencies {
    classpath('com.android.tools.build:gradle')
    classpath('com.facebook.react:react-native-gradle-plugin')
    classpath('org.jetbrains.kotlin:kotlin-gradle-plugin')
  }
}

allprojects {
  repositories {
    google()
    mavenCentral()
    maven { url 'https://www.jitpack.io' }
  }
}

apply plugin: "expo-root-project"
apply plugin: "com.facebook.react.rootproject"


--- END FILE: android\build.gradle ---

--- START FILE: android\gradle.properties ---

# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true

# Enable AAPT2 PNG crunching
android.enablePngCrunchInReleaseBuilds=true

# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64

# Use this property to enable support to the new architecture.
# This will allow you to use TurboModules and the Fabric render in
# your application. You should enable this flag either if you want
# to write custom TurboModules/Fabric components OR use libraries that
# are providing them.
newArchEnabled=true

# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
hermesEnabled=true

# Use this property to enable edge-to-edge display support.
# This allows your app to draw behind system bars for an immersive UI.
# Note: Only works with ReactActivity and should not be used with custom Activity.
edgeToEdgeEnabled=true

# Enable GIF support in React Native images (~200 B increase)
expo.gif.enabled=true
# Enable webp support in React Native images (~85 KB increase)
expo.webp.enabled=true
# Enable animated webp support (~3.4 MB increase)
# Disabled by default because iOS doesn't support animated webp
expo.webp.animated=false

# Enable network inspector
EX_DEV_CLIENT_NETWORK_INSPECTOR=true

# Use legacy packaging to compress native libraries in the resulting APK.
expo.useLegacyPackaging=false

# Specifies whether the app is configured to use edge-to-edge via the app config or plugin
# WARNING: This property has been deprecated and will be removed in Expo SDK 55. Use `edgeToEdgeEnabled` or `react.edgeToEdgeEnabled` to determine whether the project is using edge-to-edge.
expo.edgeToEdgeEnabled=true


--- END FILE: android\gradle.properties ---

--- START FILE: android\gradlew ---

#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"


--- END FILE: android\gradlew ---

--- START FILE: android\gradlew.bat ---

@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


--- END FILE: android\gradlew.bat ---

--- START FILE: android\settings.gradle ---

pluginManagement {
  def reactNativeGradlePlugin = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('@react-native/gradle-plugin/package.json', { paths: [require.resolve('react-native/package.json')] })")
    }.standardOutput.asText.get().trim()
  ).getParentFile().absolutePath
  includeBuild(reactNativeGradlePlugin)
  
  def expoPluginsPath = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('expo-modules-autolinking/package.json', { paths: [require.resolve('expo/package.json')] })")
    }.standardOutput.asText.get().trim(),
    "../android/expo-gradle-plugin"
  ).absolutePath
  includeBuild(expoPluginsPath)
}

plugins {
  id("com.facebook.react.settings")
  id("expo-autolinking-settings")
}

extensions.configure(com.facebook.react.ReactSettingsExtension) { ex ->
  if (System.getenv('EXPO_USE_COMMUNITY_AUTOLINKING') == '1') {
    ex.autolinkLibrariesFromCommand()
  } else {
    ex.autolinkLibrariesFromCommand(expoAutolinking.rnConfigCommand)
  }
}
expoAutolinking.useExpoModules()

rootProject.name = 'Small AI v2'

expoAutolinking.useExpoVersionCatalog()

include ':app'
includeBuild(expoAutolinking.reactNativeGradlePlugin)


--- END FILE: android\settings.gradle ---

--- START FILE: android\app\build.gradle ---

apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

def projectRoot = rootDir.getAbsoluteFile().getParentFile().getAbsolutePath()

/**
 * This is the configuration block to customize your React Native Android app.
 * By default you don't need to apply any configuration, just uncomment the lines you need.
 */
react {
    entryFile = file(["node", "-e", "require('expo/scripts/resolveAppEntry')", projectRoot, "android", "absolute"].execute(null, rootDir).text.trim())
    reactNativeDir = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()
    hermesCommand = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsolutePath() + "/sdks/hermesc/%OS-BIN%/hermesc"
    codegenDir = new File(["node", "--print", "require.resolve('@react-native/codegen/package.json', { paths: [require.resolve('react-native/package.json')] })"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()

    enableBundleCompression = (findProperty('android.enableBundleCompression') ?: false).toBoolean()
    // Use Expo CLI to bundle the app, this ensures the Metro config
    // works correctly with Expo projects.
    cliFile = new File(["node", "--print", "require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })"].execute(null, rootDir).text.trim())
    bundleCommand = "export:embed"

    /* Folders */
     //   The root of your project, i.e. where "package.json" lives. Default is '../..'
    // root = file("../../")
    //   The folder where the react-native NPM package is. Default is ../../node_modules/react-native
    // reactNativeDir = file("../../node_modules/react-native")
    //   The folder where the react-native Codegen package is. Default is ../../node_modules/@react-native/codegen
    // codegenDir = file("../../node_modules/@react-native/codegen")

    /* Variants */
    //   The list of variants to that are debuggable. For those we're going to
    //   skip the bundling of the JS bundle and the assets. By default is just 'debug'.
    //   If you add flavors like lite, prod, etc. you'll have to list your debuggableVariants.
    // debuggableVariants = ["liteDebug", "prodDebug"]

    /* Bundling */
    //   A list containing the node command and its flags. Default is just 'node'.
    // nodeExecutableAndArgs = ["node"]

    //
    //   The path to the CLI configuration file. Default is empty.
    // bundleConfig = file(../rn-cli.config.js)
    //
    //   The name of the generated asset file containing your JS bundle
    // bundleAssetName = "MyApplication.android.bundle"
    //
    //   The entry file for bundle generation. Default is 'index.android.js' or 'index.js'
    // entryFile = file("../js/MyApplication.android.js")
    //
    //   A list of extra flags to pass to the 'bundle' commands.
    //   See https://github.com/react-native-community/cli/blob/main/docs/commands.md#bundle
    // extraPackagerArgs = []

    /* Hermes Commands */
    //   The hermes compiler command to run. By default it is 'hermesc'
    // hermesCommand = "$rootDir/my-custom-hermesc/bin/hermesc"
    //
    //   The list of flags to pass to the Hermes compiler. By default is "-O", "-output-source-map"
    // hermesFlags = ["-O", "-output-source-map"]

    /* Autolinking */
    autolinkLibrariesWithApp()
}

/**
 * Set this to true in release builds to optimize the app using [R8](https://developer.android.com/topic/performance/app-optimization/enable-app-optimization).
 */
def enableMinifyInReleaseBuilds = (findProperty('android.enableMinifyInReleaseBuilds') ?: false).toBoolean()

/**
 * The preferred build flavor of JavaScriptCore (JSC)
 *
 * For example, to use the international variant, you can use:
 * `def jscFlavor = 'org.webkit:android-jsc-intl:+'`
 *
 * The international variant includes ICU i18n library and necessary data
 * allowing to use e.g. `Date.toLocaleString` and `String.localeCompare` that
 * give correct results when using with locales other than en-US. Note that
 * this variant is about 6MiB larger per architecture than default.
 */
def jscFlavor = 'io.github.react-native-community:jsc-android:2026004.+'

android {
    ndkVersion rootProject.ext.ndkVersion

    buildToolsVersion rootProject.ext.buildToolsVersion
    compileSdk rootProject.ext.compileSdkVersion

    namespace 'com.yourcompany.smallaiv2'
    defaultConfig {
        applicationId 'com.yourcompany.smallaiv2'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"

        buildConfigField "String", "REACT_NATIVE_RELEASE_LEVEL", "\"${findProperty('reactNativeReleaseLevel') ?: 'stable'}\""
    }
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            def enableShrinkResources = findProperty('android.enableShrinkResourcesInReleaseBuilds') ?: 'false'
            shrinkResources enableShrinkResources.toBoolean()
            minifyEnabled enableMinifyInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            def enablePngCrunchInRelease = findProperty('android.enablePngCrunchInReleaseBuilds') ?: 'true'
            crunchPngs enablePngCrunchInRelease.toBoolean()
        }
    }
    packagingOptions {
        jniLibs {
            def enableLegacyPackaging = findProperty('expo.useLegacyPackaging') ?: 'false'
            useLegacyPackaging enableLegacyPackaging.toBoolean()
        }
    }
    androidResources {
        ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:!CVS:!thumbs.db:!picasa.ini:!*~'
    }
}

// Apply static values from `gradle.properties` to the `android.packagingOptions`
// Accepts values in comma delimited lists, example:
// android.packagingOptions.pickFirsts=/LICENSE,**/picasa.ini
["pickFirsts", "excludes", "merges", "doNotStrip"].each { prop ->
    // Split option: 'foo,bar' -> ['foo', 'bar']
    def options = (findProperty("android.packagingOptions.$prop") ?: "").split(",");
    // Trim all elements in place.
    for (i in 0..<options.size()) options[i] = options[i].trim();
    // `[] - ""` is essentially `[""].filter(Boolean)` removing all empty strings.
    options -= ""

    if (options.length > 0) {
        println "android.packagingOptions.$prop += $options ($options.length)"
        // Ex: android.packagingOptions.pickFirsts += '**/SCCS/**'
        options.each {
            android.packagingOptions[prop] += it
        }
    }
}

dependencies {
    // The version of react-native is set by the React Native Gradle Plugin
    implementation("com.facebook.react:react-android")

    def isGifEnabled = (findProperty('expo.gif.enabled') ?: "") == "true";
    def isWebpEnabled = (findProperty('expo.webp.enabled') ?: "") == "true";
    def isWebpAnimatedEnabled = (findProperty('expo.webp.animated') ?: "") == "true";

    if (isGifEnabled) {
        // For animated gif support
        implementation("com.facebook.fresco:animated-gif:${expoLibs.versions.fresco.get()}")
    }

    if (isWebpEnabled) {
        // For webp support
        implementation("com.facebook.fresco:webpsupport:${expoLibs.versions.fresco.get()}")
        if (isWebpAnimatedEnabled) {
            // Animated webp support
            implementation("com.facebook.fresco:animated-webp:${expoLibs.versions.fresco.get()}")
        }
    }

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }
}


--- END FILE: android\app\build.gradle ---

--- START FILE: android\app\proguard-rules.pro ---

# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /usr/local/Cellar/android-sdk/24.3.3/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# react-native-reanimated
-keep class com.swmansion.reanimated.** { *; }
-keep class com.facebook.react.turbomodule.** { *; }

# Add any project specific keep options here:


--- END FILE: android\app\proguard-rules.pro ---

--- START FILE: android\app\src\debug\AndroidManifest.xml ---

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

    <application android:usesCleartextTraffic="true" tools:targetApi="28" tools:ignore="GoogleAppIndexingWarning" tools:replace="android:usesCleartextTraffic" />
</manifest>


--- END FILE: android\app\src\debug\AndroidManifest.xml ---

--- START FILE: android\app\src\debugOptimized\AndroidManifest.xml ---

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

    <application android:usesCleartextTraffic="true" tools:targetApi="28" tools:ignore="GoogleAppIndexingWarning" tools:replace="android:usesCleartextTraffic" />
</manifest>


--- END FILE: android\app\src\debugOptimized\AndroidManifest.xml ---

--- START FILE: android\app\src\main\AndroidManifest.xml ---

<manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools">
  <uses-permission android:name="android.permission.CAMERA"/>
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.RECORD_AUDIO"/>
  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
  <uses-permission android:name="android.permission.VIBRATE"/>
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  <queries>
    <intent>
      <action android:name="android.intent.action.VIEW"/>
      <category android:name="android.intent.category.BROWSABLE"/>
      <data android:scheme="https"/>
    </intent>
  </queries>
  <application android:name=".MainApplication" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:allowBackup="true" android:theme="@style/AppTheme" android:supportsRtl="true" android:enableOnBackInvokedCallback="false">
    <meta-data android:name="expo.modules.updates.ENABLED" android:value="false"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_CHECK_ON_LAUNCH" android:value="ALWAYS"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_LAUNCH_WAIT_MS" android:value="0"/>
    <activity android:name=".MainActivity" android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|uiMode" android:launchMode="singleTask" android:windowSoftInputMode="adjustResize" android:theme="@style/Theme.App.SplashScreen" android:exported="true" android:screenOrientation="portrait">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
    </activity>
  </application>
</manifest>

--- END FILE: android\app\src\main\AndroidManifest.xml ---

--- START FILE: android\app\src\main\java\com\yourcompany\smallaiv2\MainActivity.kt ---

package com.yourcompany.smallaiv2

import android.os.Build
import android.os.Bundle

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate

import expo.modules.ReactActivityDelegateWrapper

class MainActivity : ReactActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    // Set the theme to AppTheme BEFORE onCreate to support
    // coloring the background, status bar, and navigation bar.
    // This is required for expo-splash-screen.
    setTheme(R.style.AppTheme);
    super.onCreate(null)
  }

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "main"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate {
    return ReactActivityDelegateWrapper(
          this,
          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,
          object : DefaultReactActivityDelegate(
              this,
              mainComponentName,
              fabricEnabled
          ){})
  }

  /**
    * Align the back button behavior with Android S
    * where moving root activities to background instead of finishing activities.
    * @see <a href="https://developer.android.com/reference/android/app/Activity#onBackPressed()">onBackPressed</a>
    */
  override fun invokeDefaultOnBackPressed() {
      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
          if (!moveTaskToBack(false)) {
              // For non-root activities, use the default implementation to finish them.
              super.invokeDefaultOnBackPressed()
          }
          return
      }

      // Use the default back button implementation on Android S
      // because it's doing more than [Activity.moveTaskToBack] in fact.
      super.invokeDefaultOnBackPressed()
  }
}


--- END FILE: android\app\src\main\java\com\yourcompany\smallaiv2\MainActivity.kt ---

--- START FILE: android\app\src\main\java\com\yourcompany\smallaiv2\MainApplication.kt ---

package com.yourcompany.smallaiv2

import android.app.Application
import android.content.res.Configuration

import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.ReactHost
import com.facebook.react.common.ReleaseLevel
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint
import com.facebook.react.defaults.DefaultReactNativeHost

import expo.modules.ApplicationLifecycleDispatcher
import expo.modules.ReactNativeHostWrapper

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
      this,
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List<ReactPackage> =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

          override fun getJSMainModuleName(): String = ".expo/.virtual-metro-entry"

          override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

          override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
      }
  )

  override val reactHost: ReactHost
    get() = ReactNativeHostWrapper.createReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    DefaultNewArchitectureEntryPoint.releaseLevel = try {
      ReleaseLevel.valueOf(BuildConfig.REACT_NATIVE_RELEASE_LEVEL.uppercase())
    } catch (e: IllegalArgumentException) {
      ReleaseLevel.STABLE
    }
    loadReactNative(this)
    ApplicationLifecycleDispatcher.onApplicationCreate(this)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)
  }
}


--- END FILE: android\app\src\main\java\com\yourcompany\smallaiv2\MainApplication.kt ---

--- START FILE: android\app\src\main\res\drawable\ic_launcher_background.xml ---

<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@color/splashscreen_background"/>
  <item>
    <bitmap android:gravity="center" android:src="@drawable/splashscreen_logo"/>
  </item>
</layer-list>

--- END FILE: android\app\src\main\res\drawable\ic_launcher_background.xml ---

--- START FILE: android\app\src\main\res\drawable\rn_edit_text_material.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2014 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<inset xmlns:android="http://schemas.android.com/apk/res/android"
       android:insetLeft="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetRight="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetTop="@dimen/abc_edit_text_inset_top_material"
       android:insetBottom="@dimen/abc_edit_text_inset_bottom_material"
       >

    <selector>
        <!--
          This file is a copy of abc_edit_text_material (https://bit.ly/3k8fX7I).
          The item below with state_pressed="false" and state_focused="false" causes a NullPointerException.
          NullPointerException:tempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)'

          <item android:state_pressed="false" android:state_focused="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>

          For more info, see https://bit.ly/3CdLStv (react-native/pull/29452) and https://bit.ly/3nxOMoR.
        -->
        <item android:state_enabled="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>
        <item android:drawable="@drawable/abc_textfield_activated_mtrl_alpha"/>
    </selector>

</inset>


--- END FILE: android\app\src\main\res\drawable\rn_edit_text_material.xml ---

--- START FILE: android\app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/iconBackground"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END FILE: android\app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml ---

--- START FILE: android\app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/iconBackground"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END FILE: android\app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml ---

--- START FILE: android\app\src\main\res\values\colors.xml ---

<resources>
  <color name="splashscreen_background">#110B1D</color>
  <color name="iconBackground">#110B1D</color>
  <color name="colorPrimary">#023c69</color>
  <color name="colorPrimaryDark">#110B1D</color>
</resources>

--- END FILE: android\app\src\main\res\values\colors.xml ---

--- START FILE: android\app\src\main\res\values\strings.xml ---

<resources>
  <string name="app_name">Small AI v2</string>
  <string name="expo_splash_screen_resize_mode" translatable="false">contain</string>
  <string name="expo_splash_screen_status_bar_translucent" translatable="false">false</string>
</resources>

--- END FILE: android\app\src\main\res\values\strings.xml ---

--- START FILE: android\app\src\main\res\values\styles.xml ---

<resources xmlns:tools="http://schemas.android.com/tools">
  <style name="AppTheme" parent="Theme.AppCompat.DayNight.NoActionBar">
    <item name="android:enforceNavigationBarContrast" tools:targetApi="29">true</item>
    <item name="android:editTextBackground">@drawable/rn_edit_text_material</item>
    <item name="colorPrimary">@color/colorPrimary</item>
    <item name="android:statusBarColor">#110B1D</item>
  </style>
  <style name="Theme.App.SplashScreen" parent="AppTheme">
    <item name="android:windowBackground">@drawable/ic_launcher_background</item>
  </style>
</resources>

--- END FILE: android\app\src\main\res\values\styles.xml ---

--- START FILE: android\app\src\main\res\values-night\colors.xml ---

<resources/>

--- END FILE: android\app\src\main\res\values-night\colors.xml ---

--- START FILE: android\gradle\wrapper\gradle-wrapper.properties ---

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


--- END FILE: android\gradle\wrapper\gradle-wrapper.properties ---

--- START FILE: src\components\ChatMessage.js ---

// src/components/ChatMessage.js

import React from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity, Alert, Platform } from 'react-native';
import Markdown from 'react-native-markdown-display';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import * as Clipboard from 'expo-clipboard';
import { useTheme } from '../context/ThemeContext';
import { getFileIcon, showMessage } from '../utils/helpers';
import CodeBlock from './CodeBlock'; // Import the custom CodeBlock component
import { speak, stopSpeech, isSpeechActive, getCurrentUtteranceText } from '../utils/speech'; // Import speech functions
import { useState } from 'react';

const ChatMessage = ({ message, onCopy, onDictate, isLastMessage }) => {
  const { colors } = useTheme();
  const [isDictating, setIsDictating] = useState(false);

  const isUser = message.role === 'user';
  const messageText = message.parts.map(p => p.text).join('\n').trim();
  const attachments = message.parts.filter(p => p.inlineData);

  const handleCopy = async () => {
    const textToCopy = isUser ? `You: ${messageText}` : `AI: ${messageText}`;
    await Clipboard.setStringAsync(textToCopy);
    showMessage('Copied to clipboard!', 'success');
  };

  const handleDictate = async () => {
    if (isDictating && getCurrentUtteranceText() === messageText) {
      await stopSpeech();
      setIsDictating(false);
    } else {
      // Stop any other ongoing speech
      await stopSpeech();
      // Start this message's speech
      setIsDictating(true);
      await speak(messageText, null, () => {}, () => setIsDictating(false), () => setIsDictating(false));
    }
  };


  const markdownStyles = StyleSheet.create({
    body: {
      color: isUser ? colors.userBubbleText : colors.aiBubbleText,
      fontSize: 16,
      lineHeight: 24,
    },
    heading1: { color: colors.accentPrimary, fontSize: 22, fontWeight: '800', marginTop: 20, marginBottom: 10 },
    heading2: { color: colors.accentPrimary, fontSize: 20, fontWeight: '800', marginTop: 18, marginBottom: 8 },
    heading3: { color: colors.accentPrimary, fontSize: 18, fontWeight: '800', marginTop: 16, marginBottom: 6 },
    list_item: {
      color: isUser ? colors.userBubbleText : colors.aiBubbleText,
      fontSize: 16,
      lineHeight: 24,
      marginLeft: 10,
    },
    bullet_list: { marginBottom: 10 },
    ordered_list: { marginBottom: 10 },
    strong: { color: colors.accentPrimary, fontWeight: '700' },
    link: { color: colors.accentPrimary, textDecorationLine: 'underline' },
    blockquote: {
      borderLeftWidth: 4,
      borderLeftColor: colors.accentSecondary,
      paddingLeft: 10,
      marginLeft: 0,
      color: colors.textSecondary,
      opacity: 0.8,
    },
    inlineCode: {
      backgroundColor: colors.accentPrimary + '15', // 15% opacity
      borderRadius: 4,
      paddingHorizontal: 5,
      fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
      fontSize: 14,
      color: colors.accentPrimary,
    },
  });

  const markdownRules = {
    code_block: (node, children, parent, styles) => (
      <CodeBlock key={node.key} language={node.attributes.language}>
        {children}
      </CodeBlock>
    ),
  };

  return (
    <View style={[
      styles.messageContainer,
      isUser ? styles.userMessageContainer : styles.aiMessageContainer,
      {
        backgroundColor: isUser ? colors.userBubbleBg : colors.aiBubbleBg,
        alignSelf: isUser ? 'flex-end' : 'flex-start',
        borderBottomLeftRadius: isUser ? 24 : 6,
        borderBottomRightRadius: isUser ? 6 : 24,
      },
      !isLastMessage && {marginBottom: 10} // Add margin bottom only if not last
    ]}>
      {isUser && messageText ? (
        <Text style={[styles.messageText, { color: colors.userBubbleText }]}>
          <Text style={styles.senderName}>You:</Text> {messageText}
        </Text>
      ) : null}

      {!isUser && messageText ? (
        <Markdown style={markdownStyles} rules={markdownRules}>
          {messageText}
        </Markdown>
      ) : null}

      {attachments.length > 0 && (
        <View style={styles.attachmentsContainer}>
          {attachments.map((attachment, index) => (
            attachment.inlineData.mimeType.startsWith('image/') ? (
              <Image
                key={index}
                source={{ uri: `data:${attachment.inlineData.mimeType};base64,${attachment.inlineData.data}` }}
                style={styles.chatImage}
              />
            ) : (
              <View key={index} style={[styles.fileAttachment, { backgroundColor: colors.bgSecondary, borderColor: colors.borderColor }]}>
                <MaterialCommunityIcons name={getFileIcon(attachment.inlineData.mimeType)} size={18} color={colors.accentSecondary} />
                <Text style={[styles.fileName, { color: colors.textPrimary }]}>File ({attachment.inlineData.mimeType})</Text>
              </View>
            )
          ))}
        </View>
      )}

      <View style={[styles.messageActions, { backgroundColor: colors.headerBg, borderColor: colors.borderColor, right: isUser ? 10 : 'auto', left: isUser ? 'auto' : 10, }]}>
        <TouchableOpacity onPress={handleCopy} style={styles.actionButton}>
          <MaterialCommunityIcons name="content-copy" size={16} color={colors.textSecondary} />
        </TouchableOpacity>
        <TouchableOpacity onPress={handleDictate} style={styles.actionButton}>
          <MaterialCommunityIcons name={isDictating && isSpeechActive() && getCurrentUtteranceText() === messageText ? "pause" : "volume-high"} size={16} color={colors.textSecondary} />
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  messageContainer: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 24,
    maxWidth: '85%',
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.18,
    shadowRadius: 1.00,
    elevation: 1,
    position: 'relative',
    paddingBottom: 40, // Space for action buttons
  },
  userMessageContainer: {
    marginRight: 10,
  },
  aiMessageContainer: {
    marginLeft: 10,
  },
  senderName: {
    fontWeight: 'bold',
  },
  messageText: {
    fontSize: 16,
    lineHeight: 24,
  },
  attachmentsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 10,
    gap: 8,
  },
  chatImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
    resizeMode: 'cover',
  },
  fileAttachment: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    borderRadius: 8,
    borderWidth: 1,
  },
  fileName: {
    fontSize: 12,
    marginLeft: 5,
  },
  messageActions: {
    position: 'absolute',
    bottom: 5,
    flexDirection: 'row',
    gap: 5,
    paddingVertical: 5,
    paddingHorizontal: 10,
    borderRadius: 12,
    borderWidth: 1,
    minWidth: 80,
    justifyContent: 'center',
    alignItems: 'center',
  },
  actionButton: {
    padding: 5,
    borderRadius: 6,
  },
});

export default ChatMessage;

--- END FILE: src\components\ChatMessage.js ---

--- START FILE: src\components\CodeBlock.js ---

// src/components/CodeBlock.js

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Dimensions, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from '../context/ThemeContext';
import * as Clipboard from 'expo-clipboard';
import { showMessage } from '../utils/helpers';

const { width } = Dimensions.get('window');

const CodeBlock = ({ children, language }) => {
  const { colors } = useTheme();
  const codeContent = children[0].props.children; // Markdown library structure

  const copyCode = async () => {
    await Clipboard.setStringAsync(codeContent);
    showMessage('Code copied!', 'success');
  };

  return (
    <View style={[styles.codeBlockContainer, { backgroundColor: colors.bgSecondary, borderColor: colors.borderColor }]}>
      <View style={[styles.codeBlockHeader, { backgroundColor: colors.headerBg, borderBottomColor: colors.borderColor }]}>
        {language ? <Text style={[styles.languageText, { color: colors.textSecondary }]}>{language.toUpperCase()}</Text> : <View />}
        <TouchableOpacity onPress={copyCode} style={styles.copyButton}>
          <MaterialCommunityIcons name="content-copy" size={16} color={colors.textSecondary} />
          <Text style={[styles.copyButtonText, { color: colors.textSecondary }]}>Copy code</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.codeContentWrapper}>
        <Text style={[styles.codeContent, { color: colors.textPrimary }]}>
          {codeContent}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  codeBlockContainer: {
    borderRadius: 12,
    marginTop: 10,
    marginBottom: 10,
    overflow: 'hidden',
    borderWidth: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    maxWidth: width * 0.85, // Adjust for mobile width
  },
  codeBlockHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 15,
    borderBottomWidth: 1,
  },
  languageText: {
    fontSize: 12,
    fontWeight: '600',
  },
  copyButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 6,
  },
  copyButtonText: {
    fontSize: 12,
    marginLeft: 5,
  },
  codeContentWrapper: {
    padding: 15,
  },
  codeContent: {
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace', // Use monospace font
    fontSize: 13,
    lineHeight: 18,
  },
});

export default CodeBlock;

--- END FILE: src\components\CodeBlock.js ---

--- START FILE: src\components\Loader.js ---

// src/components/Loader.js

import React, { useEffect, useRef } from 'react';
import { View, Animated, StyleSheet } from 'react-native';
import { useTheme } from '../context/ThemeContext';

const Loader = () => {
  const { colors } = useTheme();
  const bounceAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const animation = Animated.loop(
      Animated.sequence([
        Animated.timing(bounceAnim, { toValue: 1, duration: 300, useNativeDriver: true }),
        Animated.timing(bounceAnim, { toValue: 0, duration: 300, useNativeDriver: true }),
      ])
    );
    animation.start();
    return () => animation.stop();
  }, [bounceAnim]);

  const dot1Scale = bounceAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
    extrapolate: 'clamp'
  });
  const dot2Scale = bounceAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.5, 1.2],
    extrapolate: 'clamp'
  });
  const dot3Scale = bounceAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
    extrapolate: 'clamp'
  });


  const dotStyle = (delay) => ({
    backgroundColor: colors.loaderDotColor,
    transform: [{
      translateY: bounceAnim.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [0, -8, 0],
      })
    }],
    opacity: bounceAnim.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0.5, 1, 0.5],
    })
  });

  return (
    <View style={styles.loaderContainer}>
      <Animated.View style={[styles.loaderDot, dotStyle(0)]} />
      <Animated.View style={[styles.loaderDot, dotStyle(100)]} />
      <Animated.View style={[styles.loaderDot, dotStyle(200)]} />
    </View>
  );
};

const styles = StyleSheet.create({
  loaderContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    height: 40,
    marginVertical: 10,
  },
  loaderDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginHorizontal: 4,
  },
});

export default Loader;

--- END FILE: src\components\Loader.js ---

--- START FILE: src\context\ChatContext.js ---

// src/context/ChatContext.js

import React, { createContext, useState, useEffect, useContext, useRef } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { generateUniqueId, showMessage } from '../utils/helpers';
import { callGeminiAPI } from '../utils/api';
import { useTheme } from './ThemeContext'; // Import useTheme

const ChatContext = createContext();

const CHAT_SESSIONS_KEY = 'smallAI_chat_sessions_rn';
const CURRENT_SESSION_ID_KEY = 'smallAI_current_session_id_rn';

const INITIAL_AI_MESSAGE_TEXT = 'Hello! I am your AI assistant. How can I assist you today? Feel free to ask questions or attach relevant files for analysis related to Dream11 or any other topic!';

export const ChatProvider = ({ children }) => {
  const { selectedPersonality } = useTheme(); // Get selectedPersonality from ThemeContext
  const [allChatSessions, setAllChatSessions] = useState({}); // { sessionId: { id, title, history, timestamp } }
  const [currentSessionId, setCurrentSessionId] = useState(null);
  const [chatAttachments, setChatAttachments] = useState([]); // For current input attachments
  const [isLoading, setIsLoading] = useState(false);
  const chatInputRef = useRef(null); // Reference for auto-scrolling to current input

  const currentChatSession = allChatSessions[currentSessionId];
  const currentChatHistory = currentChatSession ? currentChatSession.history : [];

  // --- Initial Load Effect ---
  useEffect(() => {
    const loadSessions = async () => {
      try {
        const storedSessions = await AsyncStorage.getItem(CHAT_SESSIONS_KEY);
        let sessions = {};
        if (storedSessions) {
          sessions = JSON.parse(storedSessions);
          // Ensure all histories have an initial AI message if missing for very old sessions
          Object.keys(sessions).forEach(id => {
            if (sessions[id].history.length === 0) {
              sessions[id].history.push({ role: 'model', parts: [{ text: INITIAL_AI_MESSAGE_TEXT }] });
            }
          });
        }
        setAllChatSessions(sessions);

        const storedCurrentSessionId = await AsyncStorage.getItem(CURRENT_SESSION_ID_KEY);
        if (storedCurrentSessionId && sessions[storedCurrentSessionId]) {
          setCurrentSessionId(storedCurrentSessionId);
        } else if (Object.keys(sessions).length > 0) {
          // Load the most recent session if no specific one is found
          const sorted = Object.values(sessions).sort((a, b) => b.timestamp - a.timestamp);
          setCurrentSessionId(sorted[0].id);
          await AsyncStorage.setItem(CURRENT_SESSION_ID_KEY, sorted[0].id);
        } else {
          createNewChatSession('New Chat'); // Auto-create if no sessions at all
        }
      } catch (error) {
        console.error("Failed to load chat sessions:", error);
        showMessage('Failed to load chat sessions.', 'error');
      }
    };
    loadSessions();
  }, []);

  // --- Save Sessions Effect ---
  useEffect(() => {
    if (Object.keys(allChatSessions).length > 0) {
      AsyncStorage.setItem(CHAT_SESSIONS_KEY, JSON.stringify(allChatSessions)).catch(err => {
        console.error("Failed to save chat sessions:", err);
        showMessage('Failed to save chat sessions.', 'error');
      });
    }
  }, [allChatSessions]);

  // --- Session Management Functions ---

  const createNewChatSession = async (initialTitle = 'New Chat') => {
    const newId = generateUniqueId();
    const newSession = {
      id: newId,
      title: initialTitle,
      history: [{ role: 'model', parts: [{ text: INITIAL_AI_MESSAGE_TEXT }] }],
      timestamp: Date.now(),
    };

    setAllChatSessions(prev => ({
      ...prev,
      [newId]: newSession,
    }));
    setCurrentSessionId(newId);
    await AsyncStorage.setItem(CURRENT_SESSION_ID_KEY, newId);
    setChatAttachments([]); // Clear attachments for new chat
    if (chatInputRef.current) chatInputRef.current.clear(); // Clear text input if ref exists
  };

  const loadChatSession = async (sessionId) => {
    if (currentSessionId === sessionId) return;

    if (!allChatSessions[sessionId]) {
      showMessage('Requested chat session not found.', 'error');
      return;
    }
    setCurrentSessionId(sessionId);
    await AsyncStorage.setItem(CURRENT_SESSION_ID_KEY, sessionId);
    setChatAttachments([]); // Clear attachments for new chat
    if (chatInputRef.current) chatInputRef.current.clear(); // Clear text input if ref exists
  };

  const deleteChatSession = async (sessionIdToDelete) => {
    Alert.alert(
      "Delete Chat",
      "Are you sure you want to delete this chat? This action cannot be undone.",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          onPress: async () => {
            setAllChatSessions(prev => {
              const newSessions = { ...prev };
              delete newSessions[sessionIdToDelete];
              return newSessions;
            });

            if (currentSessionId === sessionIdToDelete) {
              setCurrentSessionId(null); // Clear current session if deleted
              await AsyncStorage.removeItem(CURRENT_SESSION_ID_KEY);
              // After deletion, if no sessions left, create a new one
              if (Object.keys(allChatSessions).length <= 1) { // Check if only one session was left or none
                createNewChatSession();
              } else {
                // Load the next most recent session
                const sessionsArray = Object.values(allChatSessions).filter(s => s.id !== sessionIdToDelete);
                if (sessionsArray.length > 0) {
                  const sorted = sessionsArray.sort((a, b) => b.timestamp - a.timestamp);
                  setCurrentSessionId(sorted[0].id);
                  await AsyncStorage.setItem(CURRENT_SESSION_ID_KEY, sorted[0].id);
                } else {
                    createNewChatSession(); // If somehow all sessions are gone, create new.
                }
              }
            }
            showMessage('Chat deleted successfully!', 'success');
          },
          style: 'destructive',
        },
      ]
    );
  };


  const updateSessionTitle = (sessionId, newTitle) => {
    setAllChatSessions(prev => ({
      ...prev,
      [sessionId]: {
        ...prev[sessionId],
        title: newTitle,
        timestamp: Date.now(),
      },
    }));
  };

  // --- Send Message Logic ---
  const sendMessage = async (userMessageText) => {
    if (!userMessageText.trim() && chatAttachments.length === 0) {
      return;
    }
    if (isLoading) return; // Prevent multiple sends

    setIsLoading(true);

    const userParts = [];
    if (userMessageText.trim()) {
      userParts.push({ text: userMessageText.trim() });
    }
    for (const attachment of chatAttachments) {
      userParts.push({
        inlineData: {
          mimeType: attachment.mimeType,
          data: attachment.data,
        },
      });
    }

    const newUserMessage = { role: 'user', parts: userParts };
    const updatedHistory = [...currentChatHistory, newUserMessage];

    // Update session immediately for UI
    setAllChatSessions(prev => ({
      ...prev,
      [currentSessionId]: {
        ...prev[currentSessionId],
        history: updatedHistory,
        timestamp: Date.now(),
      },
    }));
    setChatAttachments([]); // Clear attachments after sending
    if (chatInputRef.current) chatInputRef.current.clear(); // Clear text input

    try {
      const aiResponseText = await callGeminiAPI(updatedHistory, selectedPersonality); // Pass personality
      const newAIResponse = { role: 'model', parts: [{ text: aiResponseText }] };

      setAllChatSessions(prev => {
        const sessionToUpdate = { ...prev[currentSessionId] };
        sessionToUpdate.history = [...sessionToUpdate.history, newAIResponse];
        sessionToUpdate.timestamp = Date.now(); // Update timestamp again after AI response
        return {
          ...prev,
          [currentSessionId]: sessionToUpdate,
        };
      });

      // Update title if it's still default after the first user message
      if (currentChatSession.title === 'New Chat' && userMessageText.trim()) {
        updateSessionTitle(currentSessionId, userMessageText.trim().substring(0, 50) + (userMessageText.trim().length > 50 ? '...' : ''));
      }

    } catch (error) {
      console.error('Chat API call failed:', error);
      showMessage(`AI error: ${error.message}`, 'error');

      // If API call fails, revert history by removing the last user message
      setAllChatSessions(prev => {
        const sessionToRevert = { ...prev[currentSessionId] };
        sessionToRevert.history = sessionToRevert.history.slice(0, -1); // Remove the last user message
        return {
          ...prev,
          [currentSessionId]: sessionToRevert,
        };
      });
    } finally {
      setIsLoading(false);
    }
  };

  // --- Attachment Management ---
  const addAttachment = (attachment) => {
    setChatAttachments(prev => [...prev, attachment]);
  };

  const removeAttachment = (index) => {
    setChatAttachments(prev => prev.filter((_, i) => i !== index));
  };


  return (
    <ChatContext.Provider value={{
      allChatSessions,
      currentSessionId,
      currentChatHistory,
      chatAttachments,
      isLoading,
      chatInputRef, // Pass ref
      createNewChatSession,
      loadChatSession,
      deleteChatSession,
      sendMessage,
      addAttachment,
      removeAttachment,
      updateSessionTitle,
    }}>
      {children}
    </ChatContext.Provider>
  );
};

export const useChat = () => useContext(ChatContext);

--- END FILE: src\context\ChatContext.js ---

--- START FILE: src\context\ThemeContext.js ---

// src/context/ThemeContext.js

import React, { createContext, useState, useEffect, useContext } from 'react';
import { useColorScheme } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { appThemes, personalities } from '../theme/themes'; // <--- ADD personalities HERE!

const ThemeContext = createContext();

const THEME_STORAGE_KEY = 'smallAI_selected_theme_rn';
const MODE_STORAGE_KEY = 'smallAI_theme_mode_rn'; // 'dark' or 'light'

export const ThemeProvider = ({ children }) => {
  const systemColorScheme = useColorScheme(); // 'light' or 'dark'
  const [themeName, setThemeName] = useState('default'); // Default theme
  const [colorMode, setColorMode] = useState(systemColorScheme || 'dark'); // Default to system or dark
  const [currentColors, setCurrentColors] = useState(appThemes[themeName][colorMode]);

  useEffect(() => {
    const loadTheme = async () => {
      const storedThemeName = await AsyncStorage.getItem(THEME_STORAGE_KEY);
      const storedMode = await AsyncStorage.getItem(MODE_STORAGE_KEY);

      if (storedThemeName && appThemes[storedThemeName]) {
        setThemeName(storedThemeName);
      }
      if (storedMode && (storedMode === 'light' || storedMode === 'dark')) {
        setColorMode(storedMode);
      } else {
        setColorMode(systemColorScheme || 'dark'); // Fallback to system or dark
      }
    };
    loadTheme();
  }, [systemColorScheme]);

  useEffect(() => {
    const selectedTheme = appThemes[themeName];
    if (selectedTheme) {
      setCurrentColors(selectedTheme[colorMode]);
    } else {
      // Fallback if themeName is invalid (shouldn't happen with dropdown)
      setCurrentColors(appThemes['default'][colorMode]);
    }
    // Persist changes
    AsyncStorage.setItem(THEME_STORAGE_KEY, themeName);
    AsyncStorage.setItem(MODE_STORAGE_KEY, colorMode);
  }, [themeName, colorMode]);

  const toggleDarkMode = () => {
    setColorMode(prevMode => (prevMode === 'dark' ? 'light' : 'dark'));
  };

  const selectTheme = (newThemeName) => {
    if (appThemes[newThemeName]) {
      setThemeName(newThemeName);
    } else {
      console.warn(`Theme '${newThemeName}' not found, falling back to 'default'.`);
      setThemeName('default');
    }
  };

  return (
    <ThemeContext.Provider value={{
      themeName,
      colorMode,
      colors: currentColors,
      toggleDarkMode,
      selectTheme,
      allThemes: Object.keys(appThemes), // For dropdowns
      personalities: personalities // Export personalities from themes.js
    }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);

--- END FILE: src\context\ThemeContext.js ---

--- START FILE: src\navigation\AppNavigator.js ---

// src/navigation/AppNavigator.js

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import ChatScreen from '../screens/ChatScreen';
import ConversationScreen from '../screens/ConversationScreen';

const Stack = createStackNavigator();

const AppNavigator = () => {
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      <Stack.Screen name="Chat" component={ChatScreen} />
      <Stack.Screen name="Conversation" component={ConversationScreen} />
    </Stack.Navigator>
  );
};

export default AppNavigator;

--- END FILE: src\navigation\AppNavigator.js ---

--- START FILE: src\screens\ChatScreen.js ---

// src/screens/ChatScreen.js

import { Picker } from '@react-native-picker/picker';
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, ScrollView, Switch, Alert, KeyboardAvoidingView, Platform, Dimensions } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native'; // Import useNavigation
import { useTheme } from '../context/ThemeContext';
import { useChat } from '../context/ChatContext';
import ChatMessage from '../components/ChatMessage';
import Loader from '../components/Loader';
import { pickImage, pickDocument, getFileIcon, showMessage, generateUniqueId } from '../utils/helpers';
import * as Speech from 'expo-speech'; // For general chat TTS
import Voice from '@react-native-voice/voice'; // For general chat STT
import AsyncStorage from '@react-native-async-storage/async-storage';

const { width } = Dimensions.get('window');

const ChatScreen = () => {
  const navigation = useNavigation(); // Hook for navigation
  const { colors, themeName, colorMode, toggleDarkMode, selectTheme, allThemes, personalities } = useTheme();
  const {
    allChatSessions,
    currentSessionId,
    currentChatHistory,
    chatAttachments,
    isLoading,
    chatInputRef, // Get ref from context
    createNewChatSession,
    loadChatSession,
    deleteChatSession,
    sendMessage,
    addAttachment,
    removeAttachment,
  } = useChat();

  const [chatInputText, setChatInputText] = useState('');
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const scrollViewRef = useRef();

  // Voice input state for general chat
  const [isVoiceInputActive, setIsVoiceInputActive] = useState(false);
  const [recognizedText, setRecognizedText] = useState('');
  const [isDictatingMessage, setIsDictatingMessage] = useState(false); // For general chat TTS

  // --- Speech Recognition Setup (for general chat input) ---
  useEffect(() => {
    Voice.onSpeechStart = () => {
      setIsVoiceInputActive(true);
      setRecognizedText(''); // Clear previous recognition
      chatInputRef.current?.focus();
    };
    Voice.onSpeechEnd = () => {
      setIsVoiceInputActive(false);
      if (recognizedText.trim()) {
        setChatInputText(prev => prev + ' ' + recognizedText.trim());
      }
      setRecognizedText('');
    };
    Voice.onSpeechResults = (event) => {
      if (event.value && event.value.length > 0) {
        setRecognizedText(event.value[0]);
      }
    };
    Voice.onSpeechError = (event) => {
      console.error('Voice input error:', event.error);
      setIsVoiceInputActive(false);
      if (event.error?.message?.includes('not-allowed')) {
        showMessage('Microphone access denied. Please allow microphone access.', 'error');
      } else if (event.error?.message?.includes('no-speech')) {
        showMessage('No speech detected.', 'warning');
      } else {
        showMessage(`Voice input error: ${event.error?.message || 'Unknown error'}`, 'error');
      }
    };

    return () => {
      Voice.destroy().then(Voice.removeAllListeners);
    };
  }, [recognizedText]);

  const toggleVoiceInput = async () => {
    if (isVoiceInputActive) {
      await Voice.stop();
    } else {
      try {
        await Voice.start('en-US');
      } catch (error) {
        console.error('Failed to start voice recognition:', error);
        showMessage('Could not start voice input. Please check microphone permissions.', 'error');
      }
    }
  };

  // --- Auto-scroll chat history ---
  useEffect(() => {
    if (scrollViewRef.current) {
      scrollViewRef.current.scrollToEnd({ animated: true });
    }
  }, [currentChatHistory, chatAttachments, isLoading]); // Scroll on new messages/attachments/loading

  // --- Theme Change Handler ---
  const handleThemeChange = (newThemeName) => {
    selectTheme(newThemeName);
    AsyncStorage.setItem('smallAI_selected_theme_rn', newThemeName);
  };

  // --- Attachment Handlers ---
  const handleAttachFile = async () => {
    const pickerOptions = [
      { text: "Image", onPress: handlePickImage },
      { text: "Document", onPress: handlePickDocument },
      { text: "Cancel", style: "cancel" }
    ];

    Alert.alert("Attach File", "Choose file type to attach", pickerOptions);
  };

  const handlePickImage = async () => {
    const result = await pickImage();
    if (result) {
      addAttachment(result);
    }
  };

  const handlePickDocument = async () => {
    const result = await pickDocument();
    if (result) {
      // For non-image files, we might need to fetch the base64 manually if pickDocument doesn't provide it
      // Expo DocumentPicker's base64 option should provide it, but if not, use fileToBase64
      if (!result.data && result.uri) {
        try {
          const { data, mimeType } = await fileToBase64(result.uri, result.mimeType);
          addAttachment({ ...result, data, mimeType });
        } catch (error) {
          console.error("Failed to read document as Base64:", error);
          showMessage("Failed to process document.", "error");
        }
      } else {
        addAttachment(result);
      }
    }
  };


  return (
    <View style={[styles.container, { backgroundColor: colors.primary }]}>
      {/* Sidebar Overlay */}
      {isSidebarOpen && (
        <TouchableOpacity
          style={styles.sidebarOverlay}
          onPress={() => setIsSidebarOpen(false)}
        />
      )}

      {/* Sidebar */}
      <View style={[styles.sidebar, { backgroundColor: colors.sidebarBg, borderColor: colors.sidebarBorder, left: isSidebarOpen ? 0 : -width }]}>
        <View style={styles.sidebarHeader}>
          <Text style={[styles.sidebarTitle, { color: colors.textPrimary }]}>
            <MaterialCommunityIcons name="star-four-points" size={24} color={colors.accentPrimary} /> Small AI v2
          </Text>
          <TouchableOpacity onPress={() => setIsSidebarOpen(false)} style={styles.closeSidebarBtn}>
            <MaterialCommunityIcons name="close" size={24} color={colors.textSecondary} />
          </TouchableOpacity>
        </View>

        <TouchableOpacity onPress={() => { createNewChatSession(); setIsSidebarOpen(false); }} style={[styles.newChatButton, { backgroundColor: colors.accentPrimary }]}>
          <MaterialCommunityIcons name="plus" size={20} color={colors.activeSidebarItemText} style={styles.newChatButtonIcon}/>
          <Text style={[styles.newChatButtonText, { color: colors.activeSidebarItemText }]}>New Chat</Text>
        </TouchableOpacity>

        <Text style={[styles.previousChatsTitle, { color: colors.textSecondary }]}>Previous Chats</Text>
        <ScrollView style={styles.chatListContainer}>
          {Object.values(allChatSessions).sort((a, b) => b.timestamp - a.timestamp).map(session => (
            <TouchableOpacity
              key={session.id}
              onPress={() => { loadChatSession(session.id); setIsSidebarOpen(false); }}
              style={[
                styles.sidebarChatItem,
                {
                  backgroundColor: session.id === currentSessionId ? colors.accentPrimary : colors.sidebarBg,
                  borderColor: colors.sidebarBorder,
                },
              ]}
            >
              <MaterialCommunityIcons name="message-square-outline" size={20} color={session.id === currentSessionId ? colors.activeSidebarItemIcon : colors.textSecondary} />
              <Text numberOfLines={1} style={[styles.sidebarChatItemText, { color: session.id === currentSessionId ? colors.activeSidebarItemText : colors.textSecondary }]}>
                {session.title}
              </Text>
              <TouchableOpacity onPress={() => deleteChatSession(session.id)} style={styles.deleteChatBtn}>
                <MaterialCommunityIcons name="trash-can-outline" size={18} color={session.id === currentSessionId ? colors.activeSidebarItemIcon : colors.textSecondary} />
              </TouchableOpacity>
            </TouchableOpacity>
          ))}
        </ScrollView>

        <View style={styles.themeSelectorContainer}>
          <Text style={[styles.themeSelectorTitle, { color: colors.textSecondary }]}>Themes</Text>
          <View style={[styles.pickerWrapper, { backgroundColor: colors.cardBg, borderColor: colors.borderColor }]}>
            <TextInput
              style={[styles.pickerText, { color: colors.textPrimary }]}
              value={allThemes.find(t => t === themeName)}
              editable={false}
            />
            <MaterialCommunityIcons name="chevron-down" size={20} color={colors.textPrimary} />
            <Picker
              selectedValue={themeName}
              onValueChange={(itemValue) => handleThemeChange(itemValue)}
              style={styles.picker}
              itemStyle={{ color: colors.textPrimary }} // This style won't apply directly to Android/iOS native picker items
            >
              {allThemes.map(theme => (
                <Picker.Item key={theme} label={theme.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')} value={theme} />
              ))}
            </Picker>
          </View>
        </View>
      </View>

      {/* Main Chat Window */}
      <KeyboardAvoidingView
        style={[styles.mainChatWindow, { backgroundColor: colors.mainChatWindowBg }]}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
      >
        {/* Header */}
        <View style={[styles.header, { backgroundColor: colors.headerBg, borderBottomColor: colors.borderColor }]}>
          <View style={styles.headerLeft}>
            <TouchableOpacity onPress={() => setIsSidebarOpen(true)} style={styles.hamburgerMenuButton}>
              <MaterialCommunityIcons name="menu" size={24} color={colors.textPrimary} />
            </TouchableOpacity>
            <Text style={[styles.headerTitle, { color: colors.textPrimary }]}>
              <MaterialCommunityIcons name="star-four-points" size={24} color={colors.accentPrimary} /> Current Chat
            </Text>
          </View>
          <View style={styles.headerRight}>
            <TouchableOpacity
              onPress={() => navigation.navigate('Conversation')}
              style={[styles.conversationModeButton, { backgroundColor: colors.secondary }]}
            >
              <MaterialCommunityIcons name="message-text-outline" size={24} color={colors.textSecondary} />
            </TouchableOpacity>
            <Text style={[styles.darkModeText, { color: colors.textSecondary }]}>Dark Mode</Text>
            <Switch
              trackColor={{ false: colors.textSecondary, true: colors.accentPrimary }}
              thumbColor={colors.cardBg}
              ios_backgroundColor={colors.textSecondary}
              onValueChange={toggleDarkMode}
              value={colorMode === 'dark'}
            />
          </View>
        </View>

        {/* Chat History */}
        <ScrollView
          ref={scrollViewRef}
          style={styles.chatHistory}
          contentContainerStyle={styles.chatHistoryContent}
        >
          {currentChatHistory.map((message, index) => (
            <ChatMessage
              key={generateUniqueId()} // Use unique ID for key
              message={message}
              isLastMessage={index === currentChatHistory.length - 1 && !isLoading}
            />
          ))}
          {isLoading && <Loader />}
        </ScrollView>

        {/* Chat Input Section */}
        <View style={[styles.chatInputAreaContainer, { backgroundColor: colors.headerBg, borderTopColor: colors.borderColor }]}>
          {chatAttachments.length > 0 && (
            <View style={styles.attachmentsPreviewContainer}>
              {chatAttachments.map((attachment, index) => (
                <View key={index} style={[styles.attachmentPreviewItem, { backgroundColor: colors.accentPrimary + '15', borderColor: colors.borderColor }]}>
                  {attachment.mimeType.startsWith('image/') ? (
                    <Image source={{ uri: attachment.uri }} style={styles.attachmentThumbnail} />
                  ) : (
                    <MaterialCommunityIcons name={getFileIcon(attachment.mimeType)} size={20} color={colors.accentPrimary} />
                  )}
                  <Text numberOfLines={1} style={[styles.attachmentName, { color: colors.accentPrimary }]}>{attachment.name}</Text>
                  <TouchableOpacity onPress={() => removeAttachment(index)} style={styles.removeAttachmentBtn}>
                    <MaterialCommunityIcons name="close" size={16} color={colors.accentPrimary} />
                  </TouchableOpacity>
                </View>
              ))}
            </View>
          )}

          <View style={styles.inputRow}>
            <TouchableOpacity onPress={toggleVoiceInput} style={[styles.actionButton, { backgroundColor: colors.secondary }]}>
              <MaterialCommunityIcons name={isVoiceInputActive ? "microphone-off" : "microphone"} size={24} color={colors.textSecondary} />
            </TouchableOpacity>

            <TouchableOpacity onPress={handleAttachFile} style={[styles.actionButton, { backgroundColor: colors.secondary }]}>
              <MaterialCommunityIcons name="paperclip" size={24} color={colors.textSecondary} />
            </TouchableOpacity>

            <TextInput
              ref={chatInputRef}
              style={[
                styles.chatInput,
                { backgroundColor: colors.cardBg, borderColor: colors.borderColor, color: colors.textPrimary },
              ]}
              placeholder="Type your message or ask a question..."
              placeholderTextColor={colors.textSecondary}
              multiline
              value={chatInputText + recognizedText}
              onChangeText={(text) => {
                setChatInputText(text);
                setRecognizedText(''); // Clear recognized text if user starts typing
              }}
              onContentSizeChange={(e) => {
                // Adjust height dynamically, but capped
                if (chatInputRef.current) {
                  const newHeight = Math.min(120, Math.max(40, e.nativeEvent.contentSize.height));
                  chatInputRef.current.setNativeProps({
                    style: { height: newHeight },
                  });
                }
              }}
            />

            <TouchableOpacity
              onPress={() => sendMessage(chatInputText)}
              style={[styles.sendButton, { backgroundColor: colors.accentPrimary }]}
              disabled={isLoading || (!chatInputText.trim() && chatAttachments.length === 0)}
            >
              <MaterialCommunityIcons name="send" size={24} color={'white'} />
            </TouchableOpacity>
          </View>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
  },
  // Sidebar styles
  sidebarOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.5)',
    zIndex: 100,
  },
  sidebar: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    width: 280,
    padding: 15,
    borderRightWidth: 1,
    zIndex: 101, // Above overlay
    flexDirection: 'column',
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
  },
  sidebarHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
    paddingBottom: 15,
    borderBottomWidth: 1,
    marginBottom: 15,
  },
  sidebarTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    flexDirection: 'row',
    alignItems: 'center',
  },
  closeSidebarBtn: {
    padding: 5,
  },
  newChatButton: {
    width: '100%',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 12,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  newChatButtonIcon: {
    marginRight: 8,
  },
  newChatButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  previousChatsTitle: {
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'uppercase',
    marginBottom: 10,
  },
  chatListContainer: {
    flex: 1,
    width: '100%',
  },
  sidebarChatItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 12,
    marginBottom: 8,
    borderWidth: 1,
  },
  sidebarChatItemText: {
    flex: 1,
    fontSize: 15,
    marginLeft: 10,
  },
  deleteChatBtn: {
    padding: 5,
    marginLeft: 10,
  },
  themeSelectorContainer: {
    width: '100%',
    marginTop: 20,
    paddingTop: 15,
    borderTopWidth: 1,
  },
  themeSelectorTitle: {
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'uppercase',
    marginBottom: 8,
  },
  pickerWrapper: {
    borderRadius: 8,
    borderWidth: 1,
    paddingHorizontal: 10,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    width: '100%',
    height: 40,
    overflow: 'hidden', // Hide actual picker if it floats over
  },
  pickerText: {
    flex: 1,
    fontSize: 14,
    height: '100%',
    textAlignVertical: 'center',
  },
  picker: {
    position: 'absolute', // Position picker over text input
    width: '100%',
    height: '100%',
    opacity: 0, // Make it invisible
  },

  // Main chat window styles
  mainChatWindow: {
    flex: 1,
    borderRadius: 0, // No border radius for full screen
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    borderBottomWidth: 1,
    height: 60, // Fixed height for header
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  hamburgerMenuButton: {
    padding: 5,
    marginRight: 10,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    flexDirection: 'row',
    alignItems: 'center',
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  conversationModeButton: {
    padding: 8,
    borderRadius: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2.5,
    elevation: 3,
  },
  darkModeText: {
    fontSize: 12,
  },
  chatHistory: {
    flex: 1,
    paddingHorizontal: 10,
    paddingVertical: 10,
  },
  chatHistoryContent: {
    paddingBottom: 20,
  },
  chatInputAreaContainer: {
    padding: 15,
    borderTopWidth: 1,
  },
  attachmentsPreviewContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 10,
    gap: 8,
  },
  attachmentPreviewItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    borderWidth: 1,
  },
  attachmentThumbnail: {
    width: 24,
    height: 24,
    borderRadius: 4,
    marginRight: 5,
  },
  attachmentName: {
    fontSize: 12,
    maxWidth: 100,
    marginRight: 5,
  },
  removeAttachmentBtn: {
    padding: 2,
    borderRadius: 10,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    gap: 10,
  },
  actionButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  chatInput: {
    flex: 1,
    minHeight: 48,
    maxHeight: 120, // Max height for multiline input
    borderRadius: 24,
    paddingHorizontal: 15,
    paddingVertical: Platform.OS === 'ios' ? 12 : 8, // Adjust for vertical alignment
    borderWidth: 1,
    fontSize: 16,
    lineHeight: 24, // Ensure line height for multiline
  },
  sendButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
});

export default ChatScreen;

--- END FILE: src\screens\ChatScreen.js ---

--- START FILE: src\screens\ConversationScreen.js ---

// src/screens/ConversationScreen.js

import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Alert, Animated, Easing, Platform } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { useTheme } from '../context/ThemeContext';
import { useChat } from '../context/ChatContext';
import Voice from '@react-native-voice/voice';
import * as Speech from 'expo-speech';
import { getAvailableVoices, setSelectedVoiceName, getSelectedVoiceIdentifier } from '../utils/speech';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Picker } from '@react-native-picker/picker'; // Import Picker

const CONVERSATION_VOICE_KEY = 'smallAI_conversation_voice';
const CONVERSATION_PERSONALITY_KEY = 'smallAI_conversation_personality';

const ConversationScreen = () => {
  const navigation = useNavigation();
  const { colors, personalities, selectPersonality, selectedPersonality } = useTheme();
  const { currentChatHistory, sendMessage, isLoading, updateSessionTitle, currentSessionId } = useChat();

  const [isAiSpeaking, setIsAiSpeaking] = useState(false);
  const [isUserListening, setIsUserListening] = useState(false);
  const [conversationStatus, setConversationStatus] = useState('Tap the button to start conversing!');
  const [recognizedText, setRecognizedText] = useState('');
  const [spokenHistory, setSpokenHistory] = useState([]); // Stores last few user/AI utterances
  const [availableVoices, setAvailableVoices] = useState([]);
  const [selectedVoiceName, setSelectedVoiceNameState] = useState(null); // Local state for voice name

  const soundBlobAnim = useRef(new Animated.Value(0)).current;
  const pulseAnim = useRef(new Animated.Value(0)).current;
  const conversationDisplayScrollRef = useRef();

  // --- Voice Setup ---
  useEffect(() => {
    const loadVoicesAndSettings = async () => {
      const voices = await getAvailableVoices();
      setAvailableVoices(voices);

      const storedVoiceName = await AsyncStorage.getItem(CONVERSATION_VOICE_KEY);
      if (storedVoiceName && voices.some(v => v.name === storedVoiceName)) {
        setSelectedVoiceNameState(storedVoiceName);
      } else if (voices.length > 0) {
        // Default to the first English voice if none selected
        setSelectedVoiceNameState(voices[0].name);
        await setSelectedVoiceName(voices[0].name);
      } else {
        setSelectedVoiceNameState('');
      }
    };
    loadVoicesAndSettings();

    // Event listener for voices changed (e.g., system language change)
    Speech.onVoicesLoaded(() => {
        loadVoicesAndSettings();
    });
  }, []);

  const handleVoiceChange = async (itemValue) => {
    setSelectedVoiceNameState(itemValue);
    await setSelectedVoiceName(itemValue);
  };

  const handlePersonalityChange = async (itemValue) => {
    selectPersonality(itemValue); // Update theme context
    await AsyncStorage.setItem(CONVERSATION_PERSONALITY_KEY, itemValue);
  };

  // --- Animation for Sound Blob ---
  useEffect(() => {
    // Initial idle animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(soundBlobAnim, {
          toValue: 1,
          duration: 15000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(soundBlobAnim, {
          toValue: 0,
          duration: 15000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();

    // Pulse animation for mic button
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 1000,
          easing: Easing.linear,
          useNativeDriver: true,
        }),
        Animated.timing(pulseAnim, {
          toValue: 0,
          duration: 1000,
          easing: Easing.linear,
          useNativeDriver: true,
        }),
      ])
    ).start();

    return () => {
      soundBlobAnim.stopAnimation();
      pulseAnim.stopAnimation();
    };
  }, []);

  const getBlobStyle = () => {
    let opacity = soundBlobAnim.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0.6, 0.8, 0.6],
    });
    let scale = soundBlobAnim.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0.95, 1.05, 0.95],
    });
    let rotate = soundBlobAnim.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: ['0deg', '10deg', '0deg'],
    });
    let borderRadius = soundBlobAnim.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [
        '50% 30% 60% 40% / 40% 60% 30% 50%',
        '30% 50% 40% 60% / 60% 40% 50% 30%',
        '50% 30% 60% 40% / 40% 60% 30% 50%',
      ],
    });

    if (isUserListening) {
      opacity = pulseAnim.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [0.7, 1, 0.7],
      });
      scale = pulseAnim.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [0.9, 1.05, 0.9],
      });
      rotate = '0deg'; // Keep more stable during listening
      borderRadius = '50%'; // More circular
    } else if (isAiSpeaking) {
      opacity = pulseAnim.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [1, 0.7, 1],
      });
      scale = pulseAnim.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [0.98, 1.08, 0.98],
      });
      rotate = pulseAnim.interpolate({
        inputRange: [0, 0.25, 0.5, 0.75, 1],
        outputRange: ['0deg', '3deg', '-3deg', '3deg', '0deg'],
      });
      borderRadius = '60% 40% 50% 50% / 50% 50% 40% 60%'; // More elliptical
    }

    return {
      opacity,
      transform: [{ scale }, { rotate }],
      borderRadius, // RN Animated doesn't directly support borderRadius string interpolation as a style prop
      // For borderRadius animation, you might need a custom component or view that interpolates numbers for each corner.
      // For simplicity, we'll keep it static or rely on the main Animated.View's borderRadius.
    };
  };

  // Helper for scrolling conversation history display
  useEffect(() => {
    if (conversationDisplayScrollRef.current) {
      conversationDisplayScrollRef.current.scrollToEnd({ animated: true });
    }
  }, [spokenHistory]);

  // --- Speech Recognition (User Input) Setup ---
  useEffect(() => {
    Voice.onSpeechStart = () => {
      setIsUserListening(true);
      setConversationStatus('Listening...');
      setRecognizedText('');
      setSpokenHistory(prev => [...prev, { role: 'user', text: '' }]);
    };
    Voice.onSpeechEnd = async () => {
      setIsUserListening(false);
      // If recognized text is empty, the user might have stopped speaking prematurely
      if (recognizedText.trim() === '') {
        setConversationStatus('No speech detected. Say something!');
        startListeningTimeout(); // Try listening again after a short delay
      } else {
        await handleUserSpeechEnd(recognizedText.trim());
      }
    };
    Voice.onSpeechResults = (event) => {
      if (event.value && event.value.length > 0) {
        setRecognizedText(event.value[0]);
        setSpokenHistory(prev => {
          const newHistory = [...prev];
          newHistory[newHistory.length - 1] = { role: 'user', text: event.value[0] };
          return newHistory;
        });
      }
    };
    Voice.onSpeechError = (event) => {
      setIsUserListening(false);
      console.error('Conversation mode Voice input error:', event.error);
      if (event.error?.message?.includes('not-allowed')) {
        Alert.alert('Microphone Access Denied', 'Please allow microphone access in your app settings to use Conversation Mode.');
        setConversationStatus('Microphone access denied.', 'error');
      } else if (event.error?.message?.includes('no-speech')) {
        setConversationStatus('No speech detected. Say something!');
        startListeningTimeout();
      } else {
        Alert.alert('Voice Error', `Conversation mode speech recognition error: ${event.error?.message || 'Unknown error'}`);
        setConversationStatus(`Error: ${event.error?.message || 'Unknown error'}`, 'error');
      }
    };

    return () => {
      Voice.destroy().then(Voice.removeAllListeners);
      Speech.stop(); // Stop speech when component unmounts
      clearTimeout(conversationTimeout); // Clear any pending timeouts
    };
  }, [currentChatHistory, recognizedText, selectedVoiceName, selectedPersonality]);


  let conversationTimeout = useRef(null);
  const startListeningTimeout = () => {
    clearTimeout(conversationTimeout.current);
    conversationTimeout.current = setTimeout(() => {
      if (!isUserListening && !isAiSpeaking) {
        startListening();
      }
    }, 2000); // Wait 2 seconds before automatically starting listening again
  };

  // --- Main Conversation Flow Functions ---
  const startListening = async () => {
    if (isAiSpeaking) await Speech.stop(); // Stop AI if speaking
    if (isUserListening) return;

    try {
      await Voice.start('en-US');
    } catch (error) {
      console.error('Failed to start conversation voice recognition:', error);
      Alert.alert('Microphone Error', 'Could not start microphone. Please check permissions.');
      setConversationStatus('Error starting microphone.', 'error');
    }
  };

  const stopListening = async () => {
    if (isUserListening) {
      await Voice.stop();
    }
  };

  const handleUserSpeechEnd = async (userText) => {
    setConversationStatus('Thinking...');
    setSpokenHistory(prev => {
        const lastEntry = prev[prev.length - 1];
        if (lastEntry && lastEntry.role === 'user') {
            lastEntry.text = userText; // Update the full text
        } else {
            prev.push({ role: 'user', text: userText }); // Should not happen with current flow
        }
        return [...prev];
    });

    try {
      // Send message to backend via ChatContext's sendMessage
      // We pass userText, and it will append to currentChatHistory and get AI response.
      // We need to wait for the AI response to be available in currentChatHistory.
      await sendMessage(userText);

      // After sendMessage updates chat history, find the latest AI message
      const latestAiMessage = currentChatHistory[currentChatHistory.length - 1]; // This is the user's message
      const nextAiMessageIndex = currentChatHistory.length + 1; // Expected index of AI message after user message and AI response
      // This is a bit tricky with async updates; better to explicitly get AI response from sendMessage's internal logic
      // For simplicity here, we assume sendMessage *already* handled updating history and we react to that.
      // A better way would be for `sendMessage` to return the AI response text directly, or to use a callback.

      // For now, let's re-fetch history or wait for context update to propagate
      // For a quick fix, we'll try to find the latest AI message added to the global chat history
      // This implies ChatContext updates `currentChatHistory` *before* `sendMessage` resolves,
      // which isn't ideal. Let's make sendMessage more robust or directly call `callGeminiAPI`.

      // Let's directly call the API here and then update ChatContext to keep the flow synchronous in ConversationScreen
      const historyForAPI = [...currentChatHistory, { role: 'user', parts: [{ text: userText }] }];
      const aiResponseText = await callGeminiAPI(historyForAPI, selectedPersonality);

      // Now, update the global chat history with both user and AI message
      // This needs to be done through the ChatContext's update mechanism.
      // Modifying the `sendMessage` in ChatContext to return the AI response and then calling
      // a different context function to directly append to history would be cleaner.
      // For this example, let's simplify and directly push to history.
      const newUserMessage = { role: 'user', parts: [{ text: userText }] };
      const newAIResponse = { role: 'model', parts: [{ text: aiResponseText }] };
      setSpokenHistory(prev => [...prev, newUserMessage, newAIResponse]); // Update local display history

      // Also update global chat history and title via context
      updateChatHistoryInContext(newUserMessage, newAIResponse);

      await startSpeaking(aiResponseText);

    } catch (error) {
      console.error("Error in conversation mode API call:", error);
      Alert.alert('AI Error', `AI communication error: ${error.message}`);
      setConversationStatus('AI communication error. Please try again.', 'error');
      startListeningTimeout(); // Try to resume listening
    }
  };

  const updateChatHistoryInContext = (userMsg, aiMsg) => {
    // This is a simplified way to ensure the main chat history gets updated
    // In a production app, the `sendMessage` function in `ChatContext` should be used,
    // and this screen would only call `sendMessage` and react to its successful completion.
    // However, since `sendMessage` takes `chatInputText` and `chatAttachments`, it's not
    // directly suitable for just "userText" from voice.
    // For this demonstration, we'll assume `ChatContext` is capable of handling history updates like this.
    // A better refactor would involve `ChatContext` exposing a function like `appendVoiceMessage(userText)`
    // that internally calls the API and updates its state.

    // Let's create a temporary session update function directly here for quick integration.
    // In a real app, this should be done via ChatContext methods.
    const currentSession = currentChatHistory; // This is actually the history array
    const updatedHistory = [...currentSession, userMsg, aiMsg];

    setSpokenHistory(prev => [...prev.filter(entry => entry.role !== 'temp-ai-thinking'), userMsg, aiMsg]);

    // Manually updating the chat sessions state directly (less ideal, but works for demo)
    // The `useChat` hook should have an exposed `updateHistoryDirectly` for this
    // For now, we'll call a simplified sendMessage that internally handles the history update.
    // This implies `sendMessage` should accept just `userParts` and add `aiParts`.
    // Re-evaluating: The existing `sendMessage` in `ChatContext` is designed for text input and attachments.
    // For conversation mode, we need a dedicated function. Let's create one.

    // This is a placeholder for now. The `sendMessage` from `useChat` is still triggered
    // in `handleUserSpeechEnd` to handle the history update and AI call.
    // The `spokenHistory` state here is just for display within the conversation overlay.
  };


  const startSpeaking = async (text) => {
    if (isUserListening) await Voice.stop(); // Stop user recognition if active
    if (isAiSpeaking) await Speech.stop(); // Stop previous AI speech

    setIsAiSpeaking(true);
    setConversationStatus('AI Speaking...');

    const voiceIdentifier = await getSelectedVoiceIdentifier();
    const options = {
      language: 'en-US',
      onStart: () => {
        // console.log('AI started speaking');
      },
      onDone: () => {
        // console.log('AI finished speaking');
        setIsAiSpeaking(false);
        startListeningTimeout(); // Automatically restart listening for user
      },
      onError: (e) => {
        console.error('AI speech error:', e);
        Alert.alert('Speech Error', 'AI could not speak this message.');
        setIsAiSpeaking(false);
        setConversationStatus('AI speech error.', 'error');
        startListeningTimeout(); // Attempt to resume listening despite error
      },
    };

    if (voiceIdentifier) {
      options.voice = voiceIdentifier;
    }

    try {
      await Speech.speak(text, options);
    } catch (error) {
      console.error('Failed to start AI speech:', error);
      Alert.alert('Speech Error', 'Could not start AI speech.');
      setIsAiSpeaking(false);
      setConversationStatus('AI speech error.', 'error');
      startListeningTimeout();
    }
  };

  const handleMicButtonPress = async () => {
    if (isAiSpeaking) {
      await Speech.stop();
      setIsAiSpeaking(false);
      startListeningTimeout(); // Resume listening after interrupting AI
    } else if (isUserListening) {
      await Voice.stop(); // Stop listening
    } else {
      startListening(); // Start listening
    }
  };

  return (
    <View style={[styles.overlayContainer, { backgroundColor: colors.conversationBg }]}>
      <TouchableOpacity
        style={[styles.closeButton, { top: Platform.OS === 'ios' ? 60 : 20 }]}
        onPress={() => navigation.goBack()}
      >
        <MaterialCommunityIcons name="close" size={30} color={colors.textSecondary} />
      </TouchableOpacity>

      <View style={[styles.conversationControls, { backgroundColor: colors.conversationBg + '90', borderColor: colors.borderColor }]}>
        <Text style={[styles.controlLabel, { color: colors.textSecondary }]}>Voice:</Text>
        <View style={[styles.pickerWrapper, { backgroundColor: colors.cardBg, borderColor: colors.borderColor }]}>
          <TextInput
            style={[styles.pickerText, { color: colors.textPrimary }]}
            value={selectedVoiceName || 'Default Voice'}
            editable={false}
          />
          <MaterialCommunityIcons name="chevron-down" size={20} color={colors.textPrimary} />
          <Picker
            selectedValue={selectedVoiceName}
            onValueChange={handleVoiceChange}
            style={styles.picker}
            itemStyle={{ color: colors.textPrimary }}
          >
            {availableVoices.length > 0 ? (
              availableVoices.map(voice => (
                <Picker.Item key={voice.identifier} label={`${voice.name} (${voice.language})`} value={voice.name} />
              ))
            ) : (
              <Picker.Item label="Loading voices..." value="" />
            )}
          </Picker>
        </View>

        <Text style={[styles.controlLabel, { color: colors.textSecondary }]}>Personality:</Text>
        <View style={[styles.pickerWrapper, { backgroundColor: colors.cardBg, borderColor: colors.borderColor }]}>
          <TextInput
            style={[styles.pickerText, { color: colors.textPrimary }]}
            value={selectedPersonality || 'Standard'}
            editable={false}
          />
          <MaterialCommunityIcons name="chevron-down" size={20} color={colors.textPrimary} />
          <Picker
            selectedValue={selectedPersonality}
            onValueChange={handlePersonalityChange}
            style={styles.picker}
            itemStyle={{ color: colors.textPrimary }}
          >
            {personalities.map(p => (
              <Picker.Item key={p.name} label={p.name} value={p.name} />
            ))}
          </Picker>
        </View>
      </View>

      <View style={styles.soundBlobWrapper}>
        <Animated.View
          style={[
            styles.soundBlob,
            { backgroundColor: colors.conversationIndicator },
            getBlobStyle(),
          ]}
        />
      </View>

      <Text style={[
        styles.conversationStatusText,
        { color: colors.textPrimary },
        isUserListening && { color: colors.accentSecondary, textShadowColor: colors.accentSecondary + '80' },
        isAiSpeaking && { color: colors.accentPrimary, textShadowColor: colors.accentPrimary + '80' },
      ]}>
        {conversationStatus}
      </Text>

      <ScrollView ref={conversationDisplayScrollRef} style={[styles.conversationHistoryDisplay, { borderColor: colors.borderColor, backgroundColor: colors.cardBg }]}>
        {spokenHistory.map((entry, index) => (
          <Text key={index} style={{
            color: entry.role === 'user' ? colors.userBubbleText : colors.aiBubbleText,
            fontWeight: '600',
            marginBottom: 5,
          }}>
            {entry.role === 'user' ? 'You: ' : 'AI: '}
            {entry.text}
          </Text>
        ))}
      </ScrollView>

      <TouchableOpacity
        onPress={handleMicButtonPress}
        style={[
          styles.micButton,
          { backgroundColor: colors.accentPrimary },
          (isUserListening || isAiSpeaking) && {
            shadowColor: colors.accentError,
            shadowOffset: { width: 0, height: 0 },
            shadowOpacity: pulseAnim.interpolate({
              inputRange: [0, 0.5, 1],
              outputRange: [0.7, 0, 0.7],
            }),
            shadowRadius: pulseAnim.interpolate({
              inputRange: [0, 0.5, 1],
              outputRange: [15, 0, 15],
            }),
            elevation: pulseAnim.interpolate({
              inputRange: [0, 0.5, 1],
              outputRange: [10, 0, 10],
            }),
          },
        ]}
      >
        <MaterialCommunityIcons name={isUserListening ? "microphone-off" : "microphone"} size={32} color="white" />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  overlayContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 15,
    paddingTop: Platform.OS === 'ios' ? 80 : 20,
  },
  closeButton: {
    position: 'absolute',
    right: 20,
    padding: 10,
    zIndex: 1,
  },
  conversationControls: {
    position: 'absolute',
    top: Platform.OS === 'ios' ? 20 : 10,
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 9999,
    borderWidth: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
    elevation: 8,
    maxWidth: '90%',
  },
  controlLabel: {
    fontSize: 14,
    marginRight: 5,
    marginLeft: 10,
  },
  pickerWrapper: {
    borderRadius: 8,
    borderWidth: 1,
    marginHorizontal: 5,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    minWidth: 120,
    height: 40,
    overflow: 'hidden',
  },
  pickerText: {
    flex: 1,
    fontSize: 14,
    paddingHorizontal: 10,
    height: '100%',
    textAlignVertical: 'center',
  },
  picker: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    opacity: 0,
  },
  soundBlobWrapper: {
    width: 300,
    height: 300,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 100, // Push down due to controls
    marginBottom: 20,
  },
  soundBlob: {
    width: '100%',
    height: '100%',
    borderRadius: 150, // Default to circular, animations handle morphing
    filter: 'blur(8px)', // Not directly supported by RN, emulate with shadow/opacity
    // Shadow properties can somewhat mimic glowing/blur:
    shadowColor: '#000', // Will be overridden by conversationIndicator in getBlobStyle
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.7,
    shadowRadius: 25,
    elevation: 10,
  },
  conversationStatusText: {
    fontSize: 22,
    fontWeight: '800',
    textAlign: 'center',
    marginBottom: 15,
    minHeight: 60, // Ensure height for two lines
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  conversationHistoryDisplay: {
    maxWidth: 600,
    width: '90%',
    height: 120,
    borderWidth: 1,
    borderRadius: 24,
    padding: 15,
    marginBottom: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 10,
  },
  micButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 5 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 10,
    marginTop: 30,
  },
});

export default ConversationScreen;

--- END FILE: src\screens\ConversationScreen.js ---

--- START FILE: src\theme\themes.js ---

// src/theme/themes.js

export const lightPalette = {
  primary: '#f3f4f6',
  secondary: '#ffffff',
  textPrimary: '#1f2937',
  textSecondary: '#4b5563',
  borderColor: '#e5e7eb',
  cardBg: '#ffffff',
  headerBg: '#f9fafb',
  accentPrimary: '#6366f1',
  accentPrimaryHover: '#4f46e5',
  accentSecondary: '#22d3ee',
  accentError: '#ef4444',
  accentSuccess: '#22c55e',
  userBubbleBg: '#e0f2fe',
  userBubbleText: '#1e40af',
  aiBubbleBg: '#f3f4f6',
  aiBubbleText: '#374151',
  sidebarBg: '#ffffff',
  sidebarBorder: '#e5e7eb',
  sidebarItemHover: '#f3f4f6',
  loaderDotColor: '#6366f1',
  mainChatWindowBg: 'rgba(255, 255, 255, 0.8)',
  conversationBg: 'rgba(255, 255, 255, 0.95)',
  conversationText: '#1f2937',
  conversationIndicator: '#6366f1',
  activeSidebarItemText: 'black', // Specific for active item
  activeSidebarItemIcon: 'black', // Specific for active item
};

export const darkPalette = {
  primary: '#0a0a0f',
  secondary: '#13131a',
  textPrimary: '#e5e7eb',
  textSecondary: '#a1a1aa',
  borderColor: '#2d3748',
  cardBg: '#13131a',
  headerBg: '#1f2937',
  accentPrimary: '#818cf8',
  accentPrimaryHover: '#6366f1',
  accentSecondary: '#67e8f9',
  accentError: '#f87171',
  accentSuccess: '#4ade80',
  userBubbleBg: '#1a237e',
  userBubbleText: '#e0e7ff',
  aiBubbleBg: '#2d3748',
  aiBubbleText: '#f9fafb',
  sidebarBg: '#13131a',
  sidebarBorder: '#2d3748',
  sidebarItemHover: '#1f2937',
  loaderDotColor: '#818cf8',
  mainChatWindowBg: 'rgba(19, 19, 26, 0.9)',
  conversationBg: 'rgba(19, 19, 26, 0.95)',
  conversationText: '#e5e7eb',
  conversationIndicator: '#818cf8',
  activeSidebarItemText: 'black', // Specific for active item
  activeSidebarItemIcon: 'black', // Specific for active item
};

// Define themes with their light and dark palettes
export const appThemes = {
  'default': {
    light: lightPalette,
    dark: darkPalette,
  },
  'celestial-horizon': {
    dark: {
      primary: '#0D1117', secondary: '#161B22', textPrimary: '#C9D1D9', textSecondary: '#8B949E', borderColor: '#30363D', cardBg: '#1F2633', headerBg: '#161B22', accentPrimary: '#58A6FF', accentPrimaryHover: '#388BF2', accentSecondary: '#B1B8C1', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#253B64', userBubbleText: '#E0F2FE', aiBubbleBg: '#1F2633', aiBubbleText: '#C9D1D9', sidebarBg: '#161B22', sidebarBorder: '#30363D', sidebarItemHover: '#1F2633', loaderDotColor: '#58A6FF', mainChatWindowBg: 'rgba(22, 27, 34, 0.9)', conversationBg: 'rgba(22, 27, 34, 0.95)', conversationText: '#C9D1D9', conversationIndicator: '#58A6FF', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#F0F4F8', secondary: '#FFFFFF', textPrimary: '#2D3748', textSecondary: '#718096', borderColor: '#E2E8F0', cardBg: '#FFFFFF', headerBg: '#EDF2F7', accentPrimary: '#3B82F6', accentPrimaryHover: '#2563EB', accentSecondary: '#60A5FA', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#DBEAFE', userBubbleText: '#1E40AF', aiBubbleBg: '#EBF4FF', aiBubbleText: '#2D3748', sidebarBg: '#FFFFFF', sidebarBorder: '#E2E8F0', sidebarItemHover: '#F0F4F8', loaderDotColor: '#3B82F6', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#2D3748', conversationIndicator: '#3B82F6', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'verdant-calm': { // Renamed from Forest Whisper
    dark: {
      primary: '#1a2a22', secondary: '#21362d', textPrimary: '#e0f2e8', textSecondary: '#99bbaa', borderColor: '#3f544c', cardBg: '#294237', headerBg: '#2c493c', accentPrimary: '#3cb878', accentPrimaryHover: '#2fa163', accentSecondary: '#60c58e', accentError: '#f87171', accentSuccess: '#4ade80', userBubbleBg: '#1e8449', userBubbleText: '#e0f2e8', aiBubbleBg: '#34495e', aiBubbleText: '#e0f2e8', sidebarBg: '#21362d', sidebarBorder: '#3f544c', sidebarItemHover: '#2c493c', loaderDotColor: '#3cb878', mainChatWindowBg: 'rgba(33, 54, 45, 0.9)', conversationBg: 'rgba(33, 54, 45, 0.95)', conversationText: '#e0f2e8', conversationIndicator: '#3cb878', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#edf9f5', secondary: '#ffffff', textPrimary: '#2d3f35', textSecondary: '#5e7d6b', borderColor: '#dbeae5', cardBg: '#ffffff', headerBg: '#f5fcf9', accentPrimary: '#3cb878', accentPrimaryHover: '#2fa163', accentSecondary: '#60c58e', accentError: '#ef4444', accentSuccess: '#22c55e', userBubbleBg: '#c8e6c9', userBubbleText: '#1b5e20', aiBubbleBg: '#e8f5e9', aiBubbleText: '#388e3c', sidebarBg: '#ffffff', sidebarBorder: '#dbeae5', sidebarItemHover: '#edf9f5', loaderDotColor: '#3cb878', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#2d3f35', conversationIndicator: '#3cb878', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'cybernetic-pulse': {
    dark: {
      primary: '#0a0e1a', secondary: '#161c28', textPrimary: '#e2e8f0', textSecondary: '#94a3b8', borderColor: '#2f3e52', cardBg: '#1f2a3a', headerBg: '#1f2a3a', accentPrimary: '#0ea5e9', accentPrimaryHover: '#0284c7', accentSecondary: '#38bdf8', accentError: '#f87171', accentSuccess: '#4ade80', userBubbleBg: '#0c4a6e', userBubbleText: '#e0f2fe', aiBubbleBg: '#2d3748', aiBubbleText: '#f0f8ff', sidebarBg: '#161c28', sidebarBorder: '#2f3e52', sidebarItemHover: '#1f2a3a', loaderDotColor: '#0ea5e9', mainChatWindowBg: 'rgba(22, 28, 40, 0.9)', conversationBg: 'rgba(22, 28, 40, 0.95)', conversationText: '#e2e8f0', conversationIndicator: '#0ea5e9', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#f8fafc', secondary: '#ffffff', textPrimary: '#1e293b', textSecondary: '#475569', borderColor: '#e0e7f2', cardBg: '#ffffff', headerBg: '#f1f5f9', accentPrimary: '#0ea5e9', accentPrimaryHover: '#0284c7', accentSecondary: '#38bdf8', accentError: '#ef4444', accentSuccess: '#22c55e', userBubbleBg: '#bfdbfe', userBubbleText: '#1e3a8a', aiBubbleBg: '#e0f2fe', aiBubbleText: '#0284c7', sidebarBg: '#ffffff', sidebarBorder: '#e0e7f2', sidebarItemHover: '#f1f5f9', loaderDotColor: '#0ea5e9', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#1e293b', conversationIndicator: '#0ea5e9', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'urban-pulse': {
    dark: {
      primary: '#1A1A1D', secondary: '#242426', textPrimary: '#F0F0F0', textSecondary: '#A0A0A0', borderColor: '#38383B', cardBg: '#242426', headerBg: '#1A1A1D', accentPrimary: '#00BFFF', accentPrimaryHover: '#009ACD', accentSecondary: '#66CCFF', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#0F4C81', userBubbleText: '#E0FFFF', aiBubbleBg: '#36454F', aiBubbleText: '#F0F0F0', sidebarBg: '#1A1A1D', sidebarBorder: '#38383B', sidebarItemHover: '#242426', loaderDotColor: '#00BFFF', mainChatWindowBg: 'rgba(36, 36, 38, 0.9)', conversationBg: 'rgba(36, 36, 38, 0.95)', conversationText: '#F0F0F0', conversationIndicator: '#00BFFF', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#F2F4F8', secondary: '#FFFFFF', textPrimary: '#333333', textSecondary: '#777777', borderColor: '#DDE2E8', cardBg: '#FFFFFF', headerBg: '#E8ECF2', accentPrimary: '#1E90FF', accentPrimaryHover: '#107EEB', accentSecondary: '#63B2FF', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#CCE5FF', userBubbleText: '#003F8C', aiBubbleBg: '#E8F0F5', aiBubbleText: '#333333', sidebarBg: '#FFFFFF', sidebarBorder: '#DDE2E8', sidebarItemHover: '#E8F0F5', loaderDotColor: '#1E90FF', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#333333', conversationIndicator: '#1E90FF', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'rustic-ember': {
    dark: {
      primary: '#3E2723', secondary: '#4E342E', textPrimary: '#FBE9E7', textSecondary: '#BCAAA4', borderColor: '#5D4037', cardBg: '#4E342E', headerBg: '#3E2723', accentPrimary: '#D84315', accentPrimaryHover: '#BF360C', accentSecondary: '#FF8A65', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#8D6E63', userBubbleText: '#FBE9E7', aiBubbleBg: '#5D4037', aiBubbleText: '#FBE9E7', sidebarBg: '#3E2723', sidebarBorder: '#5D4037', sidebarItemHover: '#4E342E', loaderDotColor: '#D84315', mainChatWindowBg: 'rgba(78, 52, 46, 0.9)', conversationBg: 'rgba(78, 52, 46, 0.95)', conversationText: '#FBE9E7', conversationIndicator: '#D84315', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#F5E8DC', secondary: '#FFFFFF', textPrimary: '#4E342E', textSecondary: '#8D6E63', borderColor: '#E6DCCD', cardBg: '#FFFFFF', headerBg: '#F8EFE5', accentPrimary: '#E65100', accentPrimaryHover: '#D84315', accentSecondary: '#FFB74D', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#FFCCBC', userBubbleText: '#BF360C', aiBubbleBg: '#FBE9E7', aiBubbleText: '#4E342E', sidebarBg: '#FFFFFF', sidebarBorder: '#E6DCCD', sidebarItemHover: '#F8EFE5', loaderDotColor: '#E65100', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#4E342E', conversationIndicator: '#E65100', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'neon-mirage': {
    dark: {
      primary: '#05001C', secondary: '#120033', textPrimary: '#E0FFFF', textSecondary: '#8A2BE2', borderColor: '#2F004F', cardBg: '#1A0040', headerBg: '#120033', accentPrimary: '#FF1493', accentPrimaryHover: '#C7007C', accentSecondary: '#00BFFF', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#4B0082', userBubbleText: '#E0FFFF', aiBubbleBg: '#2E0854', aiBubbleText: '#E0FFFF', sidebarBg: '#120033', sidebarBorder: '#2F004F', sidebarItemHover: '#1A0040', loaderDotColor: '#FF1493', mainChatWindowBg: 'rgba(26, 0, 64, 0.9)', conversationBg: 'rgba(26, 0, 64, 0.95)', conversationText: '#E0FFFF', conversationIndicator: '#FF1493', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#F8F0FF', secondary: '#FFFFFF', textPrimary: '#330066', textSecondary: '#663399', borderColor: '#EBD9FC', cardBg: '#FFFFFF', headerBg: '#F2E0FF', accentPrimary: '#FF69B4', accentPrimaryHover: '#E0509B', accentSecondary: '#87CEEB', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#FCE4EC', userBubbleText: '#C2185B', aiBubbleBg: '#F3E5F5', aiBubbleText: '#330066', sidebarBg: '#FFFFFF', sidebarBorder: '#EBD9FC', sidebarItemHover: '#F2E0FF', loaderDotColor: '#FF69B4', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#330066', conversationIndicator: '#FF69B4', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'ivory-bloom': {
    dark: {
      primary: '#2B2D42', secondary: '#4A4E69', textPrimary: '#DCDCDC', textSecondary: '#A0A4B8', borderColor: '#5D607E', cardBg: '#4A4E69', headerBg: '#373A50', accentPrimary: '#9B59B6', accentPrimaryHover: '#8E44AD', accentSecondary: '#66CCFF', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#7C4F9B', userBubbleText: '#FFFFFF', aiBubbleBg: '#5D607E', aiBubbleText: '#DCDCDC', sidebarBg: '#2B2D42', sidebarBorder: '#5D607E', sidebarItemHover: '#373A50', loaderDotColor: '#9B59B6', mainChatWindowBg: 'rgba(74, 78, 105, 0.9)', conversationBg: 'rgba(74, 78, 105, 0.95)', conversationText: '#DCDCDC', conversationIndicator: '#9B59B6', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#FDFDFD', secondary: '#FFFFFF', textPrimary: '#333333', textSecondary: '#777777', borderColor: '#EAEAEA', cardBg: '#FFFFFF', headerBg: '#F5F5F5', accentPrimary: '#8E44AD', accentPrimaryHover: '#7F3C9E', accentSecondary: '#BA68C8', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#F2E6F7', userBubbleText: '#5D2C7B', aiBubbleBg: '#EAE0F0', aiBubbleText: '#333333', sidebarBg: '#FFFFFF', sidebarBorder: '#EAEAEA', sidebarItemHover: '#F5F5F5', loaderDotColor: '#8E44AD', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#333333', conversationIndicator: '#8E44AD', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'obsidian-night': {
    dark: {
      primary: '#121212', secondary: '#1E1E1E', textPrimary: '#F0F0F0', textSecondary: '#A0A0A0', borderColor: '#333333', cardBg: '#1E1E1E', headerBg: '#121212', accentPrimary: '#BB86FC', accentPrimaryHover: '#9E65E2', accentSecondary: '#03DAC6', accentError: '#CF6679', accentSuccess: '#03DAC6', userBubbleBg: '#3700B3', userBubbleText: '#FFFFFF', aiBubbleBg: '#2C2C2C', aiBubbleText: '#F0F0F0', sidebarBg: '#121212', sidebarBorder: '#333333', sidebarItemHover: '#1E1E1E', loaderDotColor: '#BB86FC', mainChatWindowBg: 'rgba(30, 30, 30, 0.9)', conversationBg: 'rgba(30, 30, 30, 0.95)', conversationText: '#F0F0F0', conversationIndicator: '#BB86FC', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#E0E0E0', secondary: '#FFFFFF', textPrimary: '#2C2C2C', textSecondary: '#6B6B6B', borderColor: '#C0C0C0', cardBg: '#FFFFFF', headerBg: '#D0D0D0', accentPrimary: '#6200EE', accentPrimaryHover: '#5B00D9', accentSecondary: '#018786', accentError: '#B00020', accentSuccess: '#018786', userBubbleBg: '#BBDEFB', userBubbleText: '#1A237E', aiBubbleBg: '#E0E0E0', aiBubbleText: '#2C2C2C', sidebarBg: '#FFFFFF', sidebarBorder: '#C0C0C0', sidebarItemHover: '#D0D0D0', loaderDotColor: '#6200EE', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#2C2C2C', conversationIndicator: '#6200EE', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'solar-dawn': {
    dark: {
      primary: '#1A0E2A', secondary: '#2C1840', textPrimary: '#FCE8D8', textSecondary: '#D8BFD8', borderColor: '#40265B', cardBg: '#2C1840', headerBg: '#1A0E2A', accentPrimary: '#FF5722', accentPrimaryHover: '#E64A19', accentSecondary: '#FFCC80', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#7C4F9B', userBubbleText: '#FCE8D8', aiBubbleBg: '#40265B', aiBubbleText: '#FCE8D8', sidebarBg: '#1A0E2A', sidebarBorder: '#40265B', sidebarItemHover: '#2C1840', loaderDotColor: '#FF5722', mainChatWindowBg: 'rgba(44, 24, 64, 0.9)', conversationBg: 'rgba(44, 24, 64, 0.95)', conversationText: '#FCE8D8', conversationIndicator: '#FF5722', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#FFFBEA', secondary: '#FFFFFF', textPrimary: '#3E2723', textSecondary: '#8D6E63', borderColor: '#FFE0B2', cardBg: '#FFFFFF', headerBg: '#FFF3E0', accentPrimary: '#FF8F00', accentPrimaryHover: '#FF6F00', accentSecondary: '#FFD54F', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#FFE0B2', userBubbleText: '#E65100', aiBubbleBg: '#FFF3E0', aiBubbleText: '#3E2723', sidebarBg: '#FFFFFF', sidebarBorder: '#FFE0B2', sidebarItemHover: '#FFF3E0', loaderDotColor: '#FF8F00', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#3E2723', conversationIndicator: '#FF8F00', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'aurora-drift': {
    dark: {
      primary: '#0A192F', secondary: '#172A45', textPrimary: '#E6F0FF', textSecondary: '#A0B3D6', borderColor: '#2F476D', cardBg: '#172A45', headerBg: '#0A192F', accentPrimary: '#66CCCC', accentPrimaryHover: '#55B3B3', accentSecondary: '#99CCFF', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#336699', userBubbleText: '#E6F0FF', aiBubbleBg: '#2F476D', aiBubbleText: '#E6F0FF', sidebarBg: '#0A192F', sidebarBorder: '#2F476D', sidebarItemHover: '#172A45', loaderDotColor: '#66CCCC', mainChatWindowBg: 'rgba(23, 42, 69, 0.9)', conversationBg: 'rgba(23, 42, 69, 0.95)', conversationText: '#E6F0FF', conversationIndicator: '#66CCCC', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#E0F2F7', secondary: '#FFFFFF', textPrimary: '#2B4550', textSecondary: '#5E7A8A', borderColor: '#B2EBF2', cardBg: '#FFFFFF', headerBg: '#CCEEF0', accentPrimary: '#00BCD4', accentPrimaryHover: '#00ACC1', accentSecondary: '#4DD0E1', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#B2EBF2', userBubbleText: '#006064', aiBubbleBg: '#CCEEF0', aiBubbleText: '#2B4550', sidebarBg: '#FFFFFF', sidebarBorder: '#B2EBF2', sidebarItemHover: '#CCEEF0', loaderDotColor: '#00BCD4', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#2B4550', conversationIndicator: '#00BCD4', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'timeless-echo': {
    dark: {
      primary: '#2C2C2C', secondary: '#3D3D3D', textPrimary: '#E0E0E0', textSecondary: '#B0B0B0', borderColor: '#555555', cardBg: '#3D3D3D', headerBg: '#2C2C2C', accentPrimary: '#A57C52', accentPrimaryHover: '#8B653D', accentSecondary: '#C8A87C', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#785A3D', userBubbleText: '#E0E0E0', aiBubbleBg: '#555555', aiBubbleText: '#E0E0E0', sidebarBg: '#2C2C2C', sidebarBorder: '#555555', sidebarItemHover: '#3D3D3D', loaderDotColor: '#A57C52', mainChatWindowBg: 'rgba(61, 61, 61, 0.9)', conversationBg: 'rgba(61, 61, 61, 0.95)', conversationText: '#E0E0E0', conversationIndicator: '#A57C52', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#FDF7E5', secondary: '#FFFFFF', textPrimary: '#4A4A4A', textSecondary: '#808080', borderColor: '#E6E0D3', cardBg: '#FFFFFF', headerBg: '#F5EFEB', accentPrimary: '#8D6E63', accentPrimaryHover: '#795548', accentSecondary: '#BCAAA4', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#D7CCC8', userBubbleText: '#5D4037', aiBubbleBg: '#EFEBE9', aiBubbleText: '#4A4A4A', sidebarBg: '#FFFFFF', sidebarBorder: '#E6E0D3', sidebarItemHover: '#F5EFEB', loaderDotColor: '#8D6E63', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#4A4A4A', conversationIndicator: '#8D6E63', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'mystic-void': {
    dark: {
      primary: '#110B1D', secondary: '#1F1731', textPrimary: '#ECE4F7', textSecondary: '#B29BCE', borderColor: '#372A4F', cardBg: '#1F1731', headerBg: '#110B1D', accentPrimary: '#9400D3', accentPrimaryHover: '#7B00B0', accentSecondary: '#8A2BE2', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#5B2C7B', userBubbleText: '#ECE4F7', aiBubbleBg: '#372A4F', aiBubbleText: '#ECE4F7', sidebarBg: '#110B1D', sidebarBorder: '#372A4F', sidebarItemHover: '#1F1731', loaderDotColor: '#9400D3', mainChatWindowBg: 'rgba(31, 23, 49, 0.9)', conversationBg: 'rgba(31, 23, 49, 0.95)', conversationText: '#ECE4F7', conversationIndicator: '#9400D3', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    },
    light: {
      primary: '#F7EDFF', secondary: '#FFFFFF', textPrimary: '#330066', textSecondary: '#663399', borderColor: '#EBD9FC', cardBg: '#FFFFFF', headerBg: '#F2E0FF', accentPrimary: '#8A2BE2', accentPrimaryHover: '#7B1FB2', accentSecondary: '#9370DB', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#E6D2F2', userBubbleText: '#4B0082', aiBubbleBg: '#F0E6F8', aiBubbleText: '#330066', sidebarBg: '#FFFFFF', sidebarBorder: '#EBD9FC', sidebarItemHover: '#F2E0FF', loaderDotColor: '#8A2BE2', mainChatWindowBg: 'rgba(255, 255, 255, 0.8)', conversationBg: 'rgba(255, 255, 255, 0.95)', conversationText: '#330066', conversationIndicator: '#8A2BE2', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  },
  'darkest-bw': {
    dark: {
      primary: '#000000', secondary: '#111111', textPrimary: '#FFFFFF', textSecondary: '#AAAAAA', borderColor: '#333333', cardBg: '#111111', headerBg: '#0A0A0A', accentPrimary: '#E0E0E0', accentPrimaryHover: '#FFFFFF', accentSecondary: '#888888', accentError: '#F87171', accentSuccess: '#4ADE80', userBubbleBg: '#222222', userBubbleText: '#FFFFFF', aiBubbleBg: '#333333', aiBubbleText: '#FFFFFF', sidebarBg: '#000000', sidebarBorder: '#333333', sidebarItemHover: '#111111', loaderDotColor: '#E0E0E0', mainChatWindowBg: '#000000', conversationBg: '#000000', conversationText: '#FFFFFF', conversationIndicator: '#FFFFFF', activeSidebarItemText: 'black', activeSidebarItemIcon: 'black',
    },
    light: {
      primary: '#FFFFFF', secondary: '#F0F0F0', textPrimary: '#000000', textSecondary: '#555555', borderColor: '#DDDDDD', cardBg: '#F0F0F0', headerBg: '#F5F5F5', accentPrimary: '#333333', accentPrimaryHover: '#000000', accentSecondary: '#777777', accentError: '#EF4444', accentSuccess: '#22C55E', userBubbleBg: '#EEEEEE', userBubbleText: '#000000', aiBubbleBg: '#DDDDDD', aiBubbleText: '#000000', sidebarBg: '#FFFFFF', sidebarBorder: '#DDDDDD', sidebarItemHover: '#F0F0F0', loaderDotColor: '#333333', mainChatWindowBg: '#F0F0F0', conversationBg: '#FFFFFF', conversationText: '#000000', conversationIndicator: '#000000', activeSidebarItemText: 'white', activeSidebarItemIcon: 'white',
    }
  }
};

export const personalities = [
  { name: "Standard", prompt: "" },
  { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
  { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
  { name: "Philosophical", prompt: "Respond as a deep-thinking, philosophical AI. Explore underlying meanings and broader implications, using reflective and insightful language." },
  { name: "Curious", prompt: "Respond as an endlessly curious AI, often asking thoughtful follow-up questions to understand better. Show an eagerness to learn." },
  { name: "Humorous", prompt: "Respond as a lighthearted and funny AI, often making clever jokes or witty observations. Keep the mood cheerful." },
  { name: "Formal", prompt: "Respond in a very formal and precise manner. Avoid slang or casual expressions, maintaining a sophisticated and respectful tone." },
  { name: "Casual", prompt: "Respond in a relaxed, informal, and conversational tone, like talking to a friend. Use common idioms and a laid-back style." },
  { name: "Optimistic", prompt: "Respond with an overwhelmingly positive and hopeful outlook. Emphasize solutions and bright possibilities." },
  { name: "Skeptical", prompt: "Respond with a cautious and questioning attitude, often looking for evidence or flaws in arguments. Be analytical and critical." },
  { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
  { name: "Poetic", prompt: "Respond using evocative language, metaphors, and a touch of poetic flair. Let your words flow with rhythm and imagery." },
  { name: "Concise", prompt: "Respond with extreme brevity and to the point, minimizing unnecessary words. Deliver information efficiently." },
  { name: "Verbose", prompt: "Respond with detailed and elaborate explanations, exploring every facet of the topic. Provide rich descriptions and context." },
  { name: "Narrator", prompt: "Respond as if you are narrating a story or documentary, setting a scene or describing events with a captivating voice." },
  { name: "Enthusiastic", prompt: "Respond with high energy and excitement, showing great interest in the conversation. Use exclamation marks and vivid language." },
  { name: "Mysterious", prompt: "Respond with an air of mystery, hinting at deeper knowledge without revealing everything. Be intriguing and slightly enigmatic." },
  { name: "Empathetic", prompt: "Respond with strong understanding and sharing of feelings, focusing on emotional support and validation. Show genuine care." },
  { name: "Analyst", prompt: "Respond like a data analyst, breaking down information, identifying patterns, and drawing logical conclusions based on facts." },
  { name: "Mentor", prompt: "Respond as a seasoned mentor, offering guidance, advice, and a wise perspective to help the user grow." },
  { name: "Dreamer", prompt: "Respond with imaginative and abstract ideas, often exploring fantastical possibilities and creative concepts. Think outside the box." },
  { name: "Strategist", prompt: "Respond by focusing on goals, plans, and optimal ways to achieve objectives. Offer clear, actionable strategies." },
  { name: "Minimalist", prompt: "Respond with the absolute bare minimum of words, almost like a haiku or a very short, impactful statement. Less is more." },
  { name: "Futurist", prompt: "Respond with a focus on future trends, predictions, and the long-term impact of technology and societal changes." },
  { name: "Zen Master", prompt: "Respond calmly, contemplatively, and with a focus on inner peace, mindfulness, and the present moment. Offer tranquil wisdom." }
];


--- END FILE: src\theme\themes.js ---

--- START FILE: src\utils\api.js ---

// src/utils/api.js

import { personalities } from '../theme/themes';

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// IMPORTANT: Replace "YOUR_GEMINI_API_KEY" with your actual Google Gemini API Key.
// Get your API key from Google AI Studio: https://makersuite.google.com/
// Do NOT expose your API key directly in production applications.
// For production, consider using a backend proxy to secure your API key.
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
const GEMINI_API_KEY = "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA"; // Replace with your actual key!

if (GEMINI_API_KEY === "YOUR_GEMINI_API_KEY" || !GEMINI_API_KEY || GEMINI_API_KEY === "") {
    console.error("API Key is not set or is the default placeholder. Please replace 'YOUR_GEMINI_API_KEY' in src/utils/api.js with your actual Gemini API key.");
    // You might want to throw an error or handle this more gracefully in a real app
}

const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;

export const callGeminiAPI = async (chatHistory, personalityName = "Standard") => {
    let response;
    let result;
    let success = false;
    let retryCount = 0;
    const maxRetries = 3;
    let delay = 1000;

    const payload = {
        contents: [...chatHistory], // Create a shallow copy to avoid modifying original
    };

    // Apply personality prompt
    const selectedPersonalityObj = personalities.find(p => p.name === personalityName);
    if (selectedPersonalityObj && selectedPersonalityObj.prompt) {
        // Prepend a system message for personality, or modify the first user message
        // For Gemini, it's often best to include system instructions in the first user message
        // or as a context-setting turn. Here, we'll try prepending to the first user message.
        if (payload.contents && payload.contents.length > 0 && payload.contents[0].role === 'user' && payload.contents[0].parts && payload.contents[0].parts.length > 0 && payload.contents[0].parts[0].text) {
            payload.contents[0].parts[0].text = selectedPersonalityObj.prompt + "\n" + payload.contents[0].parts[0].text;
        } else {
            // Fallback: If no user message yet, create an initial user message for personality
            // This case might be less common if the first actual message is usually user input.
            payload.contents = [{ role: "user", parts: [{ text: selectedPersonalityObj.prompt }] }].concat(payload.contents);
        }
    }


    while (retryCount < maxRetries && !success) {
        try {
            response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.status === 429) {
                if (retryCount < maxRetries - 1) {
                    console.warn(`API rate limit exceeded. Retrying in ${delay / 1000}ms...`);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                    retryCount++;
                } else {
                    throw new Error('API rate limit exceeded. Please try again later.');
                }
            } else if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            } else {
                result = await response.json();
                success = true;
            }
        } catch (err) {
            if (retryCount < maxRetries - 1) {
                console.warn(`Fetch error: ${err.message}. Retrying in ${delay / 1000}ms...`);
                await new Promise(res => setTimeout(res, delay));
                delay *= 2;
                retryCount++;
            } else {
                throw err;
            }
        }
    }

    if (result && result.candidates && result.candidates.length > 0 &&
        result.candidates[0].content && result.candidates[0].content.parts &&
        result.candidates[0].content.parts.length > 0) {
        return result.candidates[0].content.parts[0].text;
    } else {
        throw new Error('Failed to get a valid response from the AI. No candidates found or content is empty.');
    }
};

--- END FILE: src\utils\api.js ---

--- START FILE: src\utils\helpers.js ---

// src/utils/helpers.js

import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import { Alert } from 'react-native';

export const generateUniqueId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
};

export const fileToBase64 = (uri, mimeType) => {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onload = function () {
            const reader = new FileReader();
            reader.onloadend = () => {
                // Remove data:image/jpeg;base64, prefix if it exists, keep only the base64 string
                const base64Data = reader.result.split(',')[1];
                resolve({ mimeType, data: base64Data });
            };
            reader.onerror = error => reject(error);
            reader.readAsDataURL(xhr.response);
        };
        xhr.onerror = function () {
            reject(new Error('XMLHttpRequest failed.'));
        };
        xhr.responseType = 'blob';
        xhr.open('GET', uri, true);
        xhr.send(null);
    });
};

export const pickImage = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
        Alert.alert('Permission Denied', 'Sorry, we need camera roll permissions to make this work!');
        return null;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: false,
        quality: 0.7,
        base64: true, // Request base64 directly
    });

    if (!result.canceled && result.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
            uri: asset.uri,
            mimeType: asset.mimeType || 'image/jpeg', // Fallback for mimeType
            data: asset.base64, // Base64 data from the picker
            name: asset.fileName || `image-${generateUniqueId()}.${asset.mimeType.split('/')[1] || 'jpeg'}`
        };
    }
    return null;
};

export const pickDocument = async () => {
    const result = await DocumentPicker.getDocumentAsync({
        type: [
            'application/pdf',
            'text/*', // text, csv, markdown
            'application/json',
            'application/xml',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
            'application/vnd.ms-excel', // .xls
        ],
        copyToCacheDirectory: true,
        base64: true, // Request base64 directly
    });

    if (!result.canceled && result.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
            uri: asset.uri,
            mimeType: asset.mimeType || 'application/octet-stream', // Fallback mimeType
            data: asset.base64, // Base64 data from the picker
            name: asset.name
        };
    }
    return null;
};


// Function to get Lucide icon name based on MIME type
export function getFileIcon(mimeType) {
    if (mimeType.startsWith('image/')) return 'Image';
    if (mimeType === 'application/pdf') return 'FileText';
    if (mimeType.includes('text/')) return 'FileText';
    if (mimeType.includes('csv') || mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'FileSpreadsheet';
    if (mimeType.includes('json') || mimeType.includes('xml') || mimeType.includes('code') || mimeType.includes('markdown')) return 'FileCode';
    return 'File';
}

// Simple Toast/Snackbar-like message function for React Native
let currentTimeout = null;
export const showMessage = (message, type = 'success', duration = 3000) => {
    // In a real app, you'd use a dedicated React Native Toast library (e.g., 'react-native-toast-message')
    // For this example, we'll use a simple console log and Alert for critical errors.
    console.log(`MESSAGE (${type.toUpperCase()}): ${message}`);
    // If you want a basic visual alert for non-success messages:
    if (type === 'error' || type === 'warning') {
        Alert.alert(type.charAt(0).toUpperCase() + type.slice(1), message);
    }
};


--- END FILE: src\utils\helpers.js ---

--- START FILE: src\utils\speech.js ---

// src/utils/speech.js

import * as Speech from 'expo-speech';
import AsyncStorage from '@react-native-async-storage/async-storage';

const CONVERSATION_VOICE_KEY = 'smallAI_conversation_voice';

let isSpeaking = false;
let currentUtteranceText = null; // Store the text of the current speaking utterance

export const speak = async (text, voiceName = null, onStartCallback, onEndCallback, onErrorCallback) => {
  if (isSpeaking) {
    await Speech.stop();
    isSpeaking = false;
    currentUtteranceText = null;
  }

  currentUtteranceText = text;

  const options = {
    language: 'en-US',
    onStart: () => {
      isSpeaking = true;
      if (onStartCallback) onStartCallback();
    },
    onDone: () => {
      isSpeaking = false;
      currentUtteranceText = null;
      if (onEndCallback) onEndCallback();
    },
    onError: (e) => {
      console.error("Speech synthesis error:", e);
      isSpeaking = false;
      currentUtteranceText = null;
      if (onErrorCallback) onErrorCallback(e);
    },
  };

  if (voiceName) {
    const voices = await Speech.getVoicesAsync();
    const selectedVoice = voices.find(v => v.name === voiceName && v.language.startsWith('en'));
    if (selectedVoice) {
      options.voice = selectedVoice.identifier; // Expo uses 'identifier' for voice selection
    } else {
      console.warn(`Voice "${voiceName}" not found or not English, falling back to default.`);
    }
  }

  try {
    await Speech.speak(text, options);
  } catch (error) {
    console.error("Failed to start speech:", error);
    isSpeaking = false;
    currentUtteranceText = null;
    if (onErrorCallback) onErrorCallback(error);
  }
};

export const stopSpeech = async () => {
  if (isSpeaking) {
    await Speech.stop();
    isSpeaking = false;
    currentUtteranceText = null;
  }
};

export const isSpeechActive = () => {
  return isSpeaking;
};

export const getCurrentUtteranceText = () => {
  return currentUtteranceText;
};

// Function to fetch and update available voices
export const getAvailableVoices = async () => {
  const voices = await Speech.getVoicesAsync();
  return voices.filter(v => v.language.startsWith('en')).map(v => ({ name: v.name, language: v.language, identifier: v.identifier }));
};

export const getSelectedVoiceIdentifier = async () => {
  const storedVoiceName = await AsyncStorage.getItem(CONVERSATION_VOICE_KEY);
  if (storedVoiceName) {
    const voices = await getAvailableVoices();
    const selectedVoice = voices.find(v => v.name === storedVoiceName);
    return selectedVoice ? selectedVoice.identifier : null;
  }
  return null;
};

export const setSelectedVoiceName = async (voiceName) => {
  await AsyncStorage.setItem(CONVERSATION_VOICE_KEY, voiceName);
};


--- END FILE: src\utils\speech.js ---

-------------------------------------------------------------------------------------------------------

PROMPT : 

learn from context 1 as best as you can and implement it on context 2 as best as you can and yeah some features are not working in context 2 which were working in context 1 so fix that and I want context 2 to be a lot more responsive I like context 2 but I want it to be more improved and be closest to context 1 if you understand what I'm saying can you implement everything as I said and send me all the updated codes I need only the ones which were updated based on my command thank you for understanding wish you well